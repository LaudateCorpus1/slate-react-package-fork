{"version":3,"file":"slate-react.js","sources":["../src/constants/event-handlers.js","../src/constants/other-handlers.js","../src/constants/data-attributes.js","../src/constants/selectors.js","../src/components/inline.js","../src/utils/offset-key.js","../src/components/leaf.js","../src/components/text.js","../src/components/block.js","../src/components/document.js","../src/utils/scroll-to-selection.js","../src/utils/remove-all-ranges.js","../src/components/content.js","../src/plugins/react/editor-props.js","../src/plugins/react/rendering.js","../src/utils/safely-get-parent-key-node.js","../src/utils/sanitize-dom-on-error.js","../src/plugins/react/commands.js","../src/plugins/react/queries.js","../src/plugins/android/diff-text.js","../src/plugins/android/composition-manager.js","../src/plugins/android/index.js","../src/plugins/debug/noop.js","../src/constants/transfer-types.js","../src/utils/clone-fragment.js","../src/utils/get-event-transfer.js","../src/utils/set-event-transfer.js","../src/plugins/dom/after.js","../src/utils/find-dom-node.js","../src/plugins/dom/before.js","../src/plugins/dom/index.js","../src/plugins/react/restore-dom.js","../src/plugins/debug/stringify-event.js","../src/plugins/debug/debug-events.js","../src/plugins/debug/debug-batch-events.js","../src/plugins/debug/debug-mutations.js","../src/plugins/react/index.js","../src/components/editor.js","../src/utils/find-dom-point.js","../src/utils/find-dom-range.js","../src/utils/find-node.js","../src/utils/find-path.js","../src/utils/find-point.js","../src/utils/find-range.js","../src/utils/get-event-range.js","../src/index.js"],"sourcesContent":["/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst EVENT_HANDLERS = [\n  'onBeforeInput',\n  'onBlur',\n  'onClick',\n  'onContextMenu',\n  'onCompositionEnd',\n  'onCompositionUpdate',\n  'onCompositionStart',\n  'onCopy',\n  'onCut',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n  'onInput',\n  'onFocus',\n  'onKeyDown',\n  'onKeyUp',\n  'onMouseDown',\n  'onMouseUp',\n  'onPaste',\n  'onSelect',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default EVENT_HANDLERS\n","/**\n * Other handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst OTHER_HANDLERS = [\n  'decorateNode',\n  'renderAnnotation',\n  'renderBlock',\n  'renderDecoration',\n  'renderDocument',\n  'renderEditor',\n  'renderInline',\n  'renderMark',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default OTHER_HANDLERS\n","/**\n * DOM data attribute strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nexport default {\n  EDITOR: 'data-slate-editor',\n  FRAGMENT: 'data-slate-fragment',\n  KEY: 'data-key',\n  LEAF: 'data-slate-leaf',\n  LENGTH: 'data-slate-length',\n  OBJECT: 'data-slate-object',\n  OFFSET_KEY: 'data-offset-key',\n  SPACER: 'data-slate-spacer',\n  STRING: 'data-slate-string',\n  TEXT: 'data-slate-object',\n  VOID: 'data-slate-void',\n  ZERO_WIDTH: 'data-slate-zero-width',\n}\n","import DATA_ATTRS from './data-attributes'\n\n/**\n * DOM selector strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nexport default {\n  BLOCK: `[${DATA_ATTRS.OBJECT}=\"block\"]`,\n  EDITOR: `[${DATA_ATTRS.EDITOR}]`,\n  INLINE: `[${DATA_ATTRS.OBJECT}=\"inline\"]`,\n  KEY: `[${DATA_ATTRS.KEY}]`,\n  LEAF: `[${DATA_ATTRS.LEAF}]`,\n  OBJECT: `[${DATA_ATTRS.OBJECT}]`,\n  STRING: `[${DATA_ATTRS.STRING}]`,\n  TEXT: `[${DATA_ATTRS.OBJECT}=\"text\"]`,\n  VOID: `[${DATA_ATTRS.VOID}]`,\n  ZERO_WIDTH: `[${DATA_ATTRS.ZERO_WIDTH}]`,\n}\n","import React from 'react'\n\nimport DATA_ATTRS from '../constants/data-attributes'\n\nexport default class Inline extends React.Component {\n  ref = React.createRef()\n\n  shouldComponentUpdate(nextProps) {\n    return this.props.node !== nextProps.node\n  }\n\n  render() {\n    const { editor, node, parent } = this.props\n\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    const attributes = {\n      [DATA_ATTRS.OBJECT]: node.object,\n      [DATA_ATTRS.KEY]: node.key,\n      ref: this.ref,\n    }\n\n    return editor.run('renderInline', {\n      attributes,\n      editor,\n      node,\n      parent,\n    })\n  }\n}\n","/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nconst PARSER = /^([\\w-]+)(?::(\\d+))?$/\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  const matches = PARSER.exec(string)\n\n  if (!matches) {\n    throw new Error(`Invalid offset key string \"${string}\".`)\n  }\n\n  const [original, key, index] = matches // eslint-disable-line no-unused-vars\n  return {\n    key,\n    index: parseInt(index, 10),\n  }\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return `${object.key}:${object.index}`\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  parse,\n  stringify,\n}\n","import React from 'react'\nimport { IS_FIREFOX } from 'slate-dev-environment'\n\nimport OffsetKey from '../utils/offset-key'\nimport DATA_ATTRS from '../constants/data-attributes'\n\nexport default class Leaf extends React.Component {\n  constructor(props) {\n    super(props)\n    this.ref = React.createRef()\n    // This component may have skipped rendering due to native operations being\n    // applied. If an undo is performed React will see the old and new shadow DOM\n    // match and not apply an update. Forces each render to actually reconcile.\n    this.forceUpdateFlag = false\n  }\n\n  shouldComponentUpdate(nextProps) {\n    // If a native operation has made the text content the same as what\n    // we are going to make it, skip. Maintains the native spell check handling.\n    const isZeroWidth = nextProps.text === ''\n    const domNode = this.ref.current\n    const domTextContent = domNode.textContent\n    const reactTextContent = isZeroWidth ? '\\uFEFF' : nextProps.text\n\n    if (domTextContent !== reactTextContent) {\n      return true\n    }\n\n    const oldDecorations = this.props.decorations.map(d => d.type).join(' ')\n    const newDecorations = nextProps.decorations.map(d => d.type).join(' ')\n\n    if (oldDecorations !== newDecorations) {\n      return true\n    }\n\n    // If we should be a zero width node, but there is some text content in the dom, then allow react to clean it up\n    if (isZeroWidth && domTextContent.replace(/[\\uFEFF]/g, '') !== '') {\n      return true\n    }\n\n    const isOnly =\n      nextProps.parent.nodes.size === 1 && nextProps.leaves.length === 1\n    const isLineBreak = false\n    const shouldHaveLineBreak =\n      (IS_FIREFOX && isLineBreak) || (!IS_FIREFOX && (isLineBreak || isOnly))\n\n    // Otherwise, we shouldn't have to touch the text node at all, we might need to strip the zero-width attributes though!\n    if (!isZeroWidth) {\n      if (domNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n        domNode.removeAttribute(DATA_ATTRS.ZERO_WIDTH)\n      }\n\n      if (domNode.hasAttribute(DATA_ATTRS.LENGTH)) {\n        domNode.removeAttribute(DATA_ATTRS.LENGTH)\n      }\n\n      if (!domNode.hasAttribute(DATA_ATTRS.STRING)) {\n        domNode.setAttribute(DATA_ATTRS.STRING, 'true')\n      }\n    } else {\n      if (!domNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n        domNode.setAttribute(DATA_ATTRS.ZERO_WIDTH, 'n')\n      }\n\n      if (!domNode.hasAttribute(DATA_ATTRS.LENGTH)) {\n        domNode.setAttribute(DATA_ATTRS.LENGTH, '0')\n      }\n\n      if (domNode.hasAttribute(DATA_ATTRS.STRING)) {\n        domNode.removeAttribute(DATA_ATTRS.STRING, 'true')\n      }\n    }\n\n    if (!shouldHaveLineBreak) {\n      for (const child of domNode.childNodes) {\n        if (child.tagName === 'BR') {\n          domNode.removeChild(child)\n        }\n      }\n    } else {\n      let hasLineBreak = false\n\n      for (const child of domNode.childNodes) {\n        if (child.tagName === 'BR') {\n          hasLineBreak = true\n          break\n        }\n      }\n\n      if (!hasLineBreak) {\n        domNode.appendChild(window.document.createElement('br'))\n      }\n    }\n\n    return false\n  }\n\n  componentDidMount() {\n    this.forceUpdateFlag = !this.forceUpdateFlag\n  }\n\n  componentDidUpdate() {\n    this.forceUpdateFlag = !this.forceUpdateFlag\n  }\n\n  render() {\n    const {\n      decorations,\n      node,\n      index,\n      offset,\n      text,\n      editor,\n      parent,\n      leaves,\n    } = this.props\n\n    const offsetKey = OffsetKey.stringify({\n      key: node.key,\n      index,\n    })\n    const isOnly = parent.nodes.size === 1 && leaves.length === 1\n    const isLineBreak = false\n    const isZeroWidth = text === ''\n    const shouldHaveLineBreak =\n      (IS_FIREFOX && isLineBreak) || (!IS_FIREFOX && (isLineBreak || isOnly))\n\n    const attrs = {\n      [DATA_ATTRS.LEAF]: true,\n      [DATA_ATTRS.OFFSET_KEY]: offsetKey,\n      key: this.forceUpdateFlag ? 'A' : 'B',\n    }\n\n    let children = isZeroWidth ? (\n      <span\n        ref={this.ref}\n        {...{\n          [DATA_ATTRS.ZERO_WIDTH]: isLineBreak ? 'n' : 'z',\n          [DATA_ATTRS.LENGTH]: 0,\n        }}\n      >\n        {'\\uFEFF'}\n        {shouldHaveLineBreak ? <br /> : null}\n      </span>\n    ) : (\n      <span\n        ref={this.ref}\n        {...{\n          [DATA_ATTRS.STRING]: true,\n        }}\n      >\n        {text}\n        {shouldHaveLineBreak ? <br /> : null}\n      </span>\n    )\n\n    if (text !== '') {\n      for (const decoration of decorations) {\n        const ret = editor.run('renderDecoration', {\n          editor,\n          decorations,\n          node,\n          offset,\n          text,\n          decoration,\n          children,\n          attributes: {\n            [DATA_ATTRS.OBJECT]: 'decoration',\n          },\n        })\n\n        if (ret) {\n          children = ret\n        }\n      }\n    }\n    return <span {...attrs}>{children}</span>\n  }\n}\n","import React from 'react'\n\nimport Leaf from './leaf'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Text node.\n *\n * @type {Component}\n */\n\nconst Text = React.forwardRef((props, ref) => {\n  const { decorations, node, parent, editor, style } = props\n  const { key } = node\n  const leaves = node.getLeaves(decorations)\n  let at = 0\n\n  return (\n    <span\n      ref={ref}\n      style={style}\n      {...{\n        [DATA_ATTRS.OBJECT]: node.object,\n        [DATA_ATTRS.KEY]: key,\n      }}\n    >\n      {leaves.map((leaf, index) => {\n        const { text } = leaf\n        const offset = at\n        at += text.length\n\n        return (\n          <Leaf\n            key={`${node.key}-${index}`}\n            block={parent}\n            editor={editor}\n            index={index}\n            decorations={leaf.decorations}\n            node={node}\n            offset={offset}\n            parent={parent}\n            leaves={leaves}\n            text={text}\n          />\n        )\n      })}\n    </span>\n  )\n})\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Text\n","import React from 'react'\nimport { PathUtils } from 'slate'\n\nimport Inline from './inline'\nimport Text from './text'\nimport DATA_ATTRS from '../constants/data-attributes'\n\nexport default class Block extends React.Component {\n  tmp = { nodeRefs: {} }\n  ref = React.createRef()\n\n  shouldComponentUpdate(nextProps) {\n    return this.props.node !== nextProps.node\n  }\n\n  render() {\n    const { editor, node, parent } = this.props\n\n    const decorations = node.getDecorations(editor)\n    const children = []\n\n    for (const child of node.nodes) {\n      const i = children.length\n\n      const refFn = ref => {\n        if (ref) {\n          this.tmp.nodeRefs[i] = ref\n        } else {\n          delete this.tmp.nodeRefs[i]\n        }\n      }\n\n      if (child.object === 'block') {\n        children.push(\n          <Block\n            ref={refFn}\n            key={child.key}\n            editor={editor}\n            node={child}\n            parent={node}\n          />\n        )\n      } else if (child.object === 'inline') {\n        children.push(\n          <Inline\n            ref={refFn}\n            key={child.key}\n            editor={editor}\n            node={child}\n            parent={node}\n          />\n        )\n      } else {\n        const decs = decorations\n          .map(d => getRelativeRange(node, i, d))\n          .filter(d => d)\n\n        children.push(\n          <Text\n            ref={refFn}\n            key={child.key}\n            editor={editor}\n            node={child}\n            parent={node}\n            decorations={decs}\n          />\n        )\n      }\n    }\n\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    const attributes = {\n      [DATA_ATTRS.OBJECT]: node.object,\n      [DATA_ATTRS.KEY]: node.key,\n      ref: this.ref,\n    }\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.isLeafBlock()) {\n      const direction = node.getTextDirection()\n      if (direction === 'rtl') attributes.dir = 'rtl'\n    }\n\n    return editor.run('renderBlock', {\n      attributes,\n      children,\n      editor,\n      node,\n      parent,\n    })\n  }\n}\n\n/**\n * Return a `range` relative to a child at `index`.\n *\n * @param {Range} range\n * @param {Number} index\n * @return {Range}\n */\n\nfunction getRelativeRange(node, index, range) {\n  if (range.isUnset) {\n    return null\n  }\n\n  const child = node.nodes.get(index)\n  let { start, end } = range\n  const { path: startPath } = start\n  const { path: endPath } = end\n  const startIndex = startPath.first()\n  const endIndex = endPath.first()\n\n  if (startIndex === index) {\n    start = start.setPath(startPath.rest())\n  } else if (startIndex < index && index <= endIndex) {\n    if (child.object === 'text') {\n      start = start.moveTo(PathUtils.create([index]), 0).setKey(child.key)\n    } else {\n      const [first] = child.texts()\n      const [firstNode, firstPath] = first\n      start = start.moveTo(firstPath, 0).setKey(firstNode.key)\n    }\n  } else {\n    start = null\n  }\n\n  if (endIndex === index) {\n    end = end.setPath(endPath.rest())\n  } else if (startIndex <= index && index < endIndex) {\n    if (child.object === 'text') {\n      const length = child.text.length\n      end = end.moveTo(PathUtils.create([index]), length).setKey(child.key)\n    } else {\n      const [last] = child.texts({ direction: 'backward' })\n      const [lastNode, lastPath] = last\n      end = end.moveTo(lastPath, lastNode.text.length).setKey(lastNode.key)\n    }\n  } else {\n    end = null\n  }\n\n  if (!start || !end) {\n    return null\n  }\n\n  range = range.setAnchor(start)\n  range = range.setFocus(end)\n  return range\n}\n","import React from 'react'\n\nimport Block from './block'\nimport Inline from './inline'\nimport Text from './text'\n\nexport default class Document extends React.Component {\n  tmp = { nodeRefs: {} }\n\n  shouldComponentUpdate(nextProps) {\n    return this.props.node !== nextProps.node\n  }\n\n  render() {\n    const { editor, node } = this.props\n\n    const children = []\n\n    for (const child of node.nodes) {\n      const Component =\n        child.object === 'text'\n          ? Text\n          : child.object === 'block' ? Block : Inline\n      const i = children.length\n\n      children.push(\n        <Component\n          key={child.key}\n          editor={editor}\n          node={child}\n          parent={node}\n          // COMPAT: We use this map of refs to lookup a DOM node down the\n          // tree of components by path.\n          ref={ref => {\n            if (ref) {\n              this.tmp.nodeRefs[i] = ref\n            } else {\n              delete this.tmp.nodeRefs[i]\n            }\n          }}\n        />\n      )\n    }\n\n    return children\n  }\n}\n","import getWindow from 'get-window'\nimport isBackward from 'selection-is-backward'\nimport { IS_SAFARI, IS_IOS } from 'slate-dev-environment'\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nconst OVERFLOWS = ['auto', 'overlay', 'scroll']\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nconst IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i)\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  let parent = el.parentNode\n  let scroller\n\n  while (!scroller) {\n    if (!parent.parentNode) break\n\n    const style = window.getComputedStyle(parent)\n    const { overflowY } = style\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent\n      break\n    }\n\n    parent = parent.parentNode\n  }\n\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n  if (!scroller) {\n    return window.document.body\n  }\n\n  return scroller\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return\n  if (!selection.anchorNode) return\n\n  const window = getWindow(selection.anchorNode)\n  const scroller = findScrollContainer(selection.anchorNode, window)\n  const isWindow =\n    scroller === window.document.body ||\n    scroller === window.document.documentElement\n  const backward = isBackward(selection)\n\n  const range = selection.getRangeAt(0).cloneRange()\n  range.collapse(backward)\n  let cursorRect = range.getBoundingClientRect()\n\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1)\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1)\n      }\n\n      cursorRect = range.getBoundingClientRect()\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0]\n        }\n      }\n    }\n  }\n\n  let width\n  let height\n  let yOffset\n  let xOffset\n  let scrollerTop = 0\n  let scrollerLeft = 0\n  let scrollerBordersY = 0\n  let scrollerBordersX = 0\n  let scrollerPaddingTop = 0\n  let scrollerPaddingBottom = 0\n  let scrollerPaddingLeft = 0\n  let scrollerPaddingRight = 0\n\n  if (isWindow) {\n    const { innerWidth, innerHeight, pageYOffset, pageXOffset } = window\n    width = innerWidth\n    height = innerHeight\n    yOffset = pageYOffset\n    xOffset = pageXOffset\n  } else {\n    const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = scroller\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth,\n      paddingTop,\n      paddingBottom,\n      paddingLeft,\n      paddingRight,\n    } = window.getComputedStyle(scroller)\n\n    const scrollerRect = scroller.getBoundingClientRect()\n    width = offsetWidth\n    height = offsetHeight\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10)\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10)\n\n    scrollerBordersY =\n      parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10)\n\n    scrollerBordersX =\n      parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10)\n\n    scrollerPaddingTop = parseInt(paddingTop, 10)\n    scrollerPaddingBottom = parseInt(paddingBottom, 10)\n    scrollerPaddingLeft = parseInt(paddingLeft, 10)\n    scrollerPaddingRight = parseInt(paddingRight, 10)\n    yOffset = scrollTop\n    xOffset = scrollLeft\n  }\n\n  const cursorTop = cursorRect.top + yOffset - scrollerTop\n  const cursorLeft = cursorRect.left + xOffset - scrollerLeft\n\n  let x = xOffset\n  let y = yOffset\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft\n  } else if (\n    cursorLeft + cursorRect.width + scrollerBordersX >\n    xOffset + width\n  ) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop\n  } else if (\n    cursorTop + cursorRect.height + scrollerBordersY >\n    yOffset + height\n  ) {\n    // selection below viewport\n    y =\n      cursorTop +\n      scrollerBordersY +\n      scrollerPaddingBottom +\n      cursorRect.height -\n      height\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y)\n  } else {\n    scroller.scrollTop = y\n    scroller.scrollLeft = x\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default scrollToSelection\n","import { IS_IE } from 'slate-dev-environment'\n\n/**\n * Cross-browser remove all ranges from a `domSelection`.\n *\n * @param {Selection} domSelection\n */\n\nfunction removeAllRanges(domSelection) {\n  // COMPAT: In IE 11, if the selection contains nested tables, then\n  // `removeAllRanges` will throw an error.\n  if (IS_IE) {\n    const range = window.document.body.createTextRange()\n    range.collapse()\n    range.select()\n  } else {\n    domSelection.removeAllRanges()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default removeAllRanges\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport warning from 'tiny-warning'\nimport throttle from 'lodash/throttle'\nimport omit from 'lodash/omit'\nimport {\n  IS_ANDROID,\n  IS_FIREFOX,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\nimport Hotkeys from 'slate-hotkeys'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\nimport Document from './document'\nimport scrollToSelection from '../utils/scroll-to-selection'\nimport removeAllRanges from '../utils/remove-all-ranges'\n\nconst FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:content')\n\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug.update = Debug('slate:update')\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nclass Content extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static __propTypes = {\n    autoCorrect: Types.bool.isRequired,\n    className: Types.string,\n    contentKey: Types.number,\n    editor: Types.object.isRequired,\n    id: Types.string,\n    onContextMenu: Types.func,\n    onEvent: Types.func.isRequired,\n    readOnly: Types.bool.isRequired,\n    role: Types.string,\n    spellCheck: Types.bool.isRequired,\n    style: Types.object,\n    tabIndex: Types.number,\n    tagName: Types.string,\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: {},\n    tagName: 'div',\n  }\n\n  /**\n   * An error boundary. If there is a render error, we increment `errorKey`\n   * which is part of the container `key` which forces a re-render from\n   * scratch.\n   *\n   * @param {Error} error\n   * @param {String} info\n   */\n\n  componentDidCatch(error, info) {\n    console.error('!!  COMPONENT DID CATCH')\n    console.error(error)\n    console.error(info)\n    debug('componentDidCatch', { error, info })\n    // The call to `setState` is required despite not setting a value.\n    // Without this call, React will not try to recreate the component tree.\n    this.setState({})\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    isUpdatingSelection: false,\n    nodeRef: React.createRef(),\n    nodeRefs: {},\n    contentKey: 0,\n    nativeSelection: {}, // Native selection object stored to check if `onNativeSelectionChange` has triggered yet\n  }\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  ref = React.createRef()\n\n  /**\n   * Set both `this.ref` and `editor.el`\n   *\n   * @type {DOMElement}\n   */\n\n  setRef = el => {\n    this.ref.current = el\n    this.props.editor.el = el\n\n    if (this.props.domRef) {\n      this.props.domRef(el)\n    }\n  }\n\n  /**\n   * Create a set of bound event handlers.\n   *\n   * @type {Object}\n   */\n\n  handlers = EVENT_HANDLERS.reduce((obj, handler) => {\n    obj[handler] = event => this.onEvent(handler, event)\n    return obj\n  }, {})\n\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Add native DOM event listeners.\n   *   - Update the selection, in case it starts focused.\n   */\n\n  componentDidMount() {\n    window.document.addEventListener(\n      'selectionchange',\n      this.onNativeSelectionChange\n    )\n\n    // COMPAT: Restrict scope of `beforeinput` to clients that support the\n    // Input Events Level 2 spec, since they are preventable events.\n    if (HAS_INPUT_EVENTS_LEVEL_2 && this.ref.current) {\n      this.ref.current.addEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n\n    this.updateSelection()\n\n    this.props.onEvent('onComponentDidMount')\n  }\n\n  /**\n   * When unmounting, remove DOM event listeners.\n   */\n\n  componentWillUnmount() {\n    if (window) {\n      window.document.removeEventListener(\n        'selectionchange',\n        this.onNativeSelectionChange\n      )\n    }\n\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.ref.current.removeEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n\n    this.props.onEvent('onComponentWillUnmount')\n  }\n\n  /**\n   * On update, update the selection.\n   */\n\n  componentDidUpdate() {\n    debug.update('componentDidUpdate')\n\n    this.updateSelection()\n    this.props.editor.clearUserActionPerformed()\n\n    this.props.onEvent('onComponentDidUpdate')\n  }\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  updateSelection = () => {\n    if (!this.ref.current) return\n    const { editor } = this.props\n\n    // While the editor is handling a composition (like for Asian input), we allow the browser to modify the DOM\n    // and we avoid modifying slate's internal representation of the document until the composition is over.\n    // Because of this the user might have typed a character at position 4, but slate thinks there is only\n    // 3 characters in the node!  So, the work around is to skip syncing slate's view of the selection to the DOM\n    // until the composition is over.\n    if (editor.isComposing() && HAS_INPUT_EVENTS_LEVEL_2) return\n\n    const { value } = editor\n    const { selection } = value\n    const { isBackward } = selection\n    const native = window.getSelection()\n    const { activeElement } = window.document\n\n    if (debug.update.enabled) {\n      debug.update('updateSelection', { selection: selection.toJSON() })\n    }\n\n    // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n    if (!native) {\n      return\n    }\n\n    const { rangeCount, anchorNode } = native\n    let updated = false\n\n    // If the Slate selection is blurred, but the DOM's active element is still\n    // the editor, we need to blur it.\n    if (selection.isBlurred && activeElement === this.ref.current) {\n      this.ref.current.blur()\n      updated = true\n    }\n\n    // If the Slate selection is unset, but the DOM selection has a range\n    // selected in the editor, we need to remove the range.\n    // However we should _not_ remove the range if the selection as\n    // reported by `getSelection` is not equal to `this.tmp.nativeSelection`\n    // as this suggests `onNativeSelectionChange` has not triggered yet (which can occur in Firefox)\n    // See: https://github.com/ianstormtaylor/slate/pull/2995\n\n    const propsToCompare = [\n      'anchorNode',\n      'anchorOffset',\n      'focusNode',\n      'focusOffset',\n      'isCollapsed',\n      'rangeCount',\n      'type',\n    ]\n\n    let selectionsEqual = true\n\n    for (const prop of propsToCompare) {\n      if (this.tmp.nativeSelection[prop] !== native[prop]) {\n        selectionsEqual = false\n      }\n    }\n\n    if (\n      selection.isUnset &&\n      rangeCount &&\n      this.isInEditor(anchorNode) &&\n      selectionsEqual\n    ) {\n      removeAllRanges(native)\n      updated = true\n    }\n\n    // If the Slate selection is focused, but the DOM's active element is not\n    // the editor, we need to focus it. We prevent scrolling because we handle\n    // scrolling to the correct selection.\n    if (selection.isFocused && activeElement !== this.ref.current) {\n      this.ref.current.focus({ preventScroll: true })\n      updated = true\n    }\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    if (selection.isFocused && selection.isSet) {\n      const current = !!native.rangeCount && native.getRangeAt(0)\n      const range = safelyFindDOMRange(editor, selection)\n\n      if (!range) {\n        warning(\n          false,\n          'Unable to find a native DOM range from the current selection.'\n        )\n\n        return\n      }\n\n      const { startContainer, startOffset, endContainer, endOffset } = range\n\n      // If the new range matches the current selection, there is nothing to fix.\n      // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n      // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n      // to check both orientations here. (2017/10/31)\n      if (current) {\n        if (\n          (startContainer === current.startContainer &&\n            startOffset === current.startOffset &&\n            endContainer === current.endContainer &&\n            endOffset === current.endOffset) ||\n          (startContainer === current.endContainer &&\n            startOffset === current.endOffset &&\n            endContainer === current.startContainer &&\n            endOffset === current.startOffset)\n        ) {\n          return\n        }\n      }\n\n      // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n      updated = true\n      this.tmp.isUpdatingSelection = true\n      removeAllRanges(native)\n\n      // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n      if (native.setBaseAndExtent) {\n        // COMPAT: Since the DOM range has no concept of backwards/forwards\n        // we need to check and do the right thing here.\n        if (isBackward) {\n          native.setBaseAndExtent(\n            range.endContainer,\n            range.endOffset,\n            range.startContainer,\n            range.startOffset\n          )\n        } else {\n          native.setBaseAndExtent(\n            range.startContainer,\n            range.startOffset,\n            range.endContainer,\n            range.endOffset\n          )\n        }\n      } else {\n        native.addRange(range)\n      }\n\n      // Only scroll to selection when a user action is performed\n      if (editor.userActionPerformed() === true) {\n        // Scroll to the selection, in case it's out of view.\n        scrollToSelection(native)\n      }\n\n      // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n      // it is still set when selection-related events from updating it fire.\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (IS_FIREFOX && this.ref.current) {\n          this.ref.current.focus()\n        }\n\n        this.tmp.isUpdatingSelection = false\n\n        debug.update('updateSelection:setTimeout', {\n          anchorOffset: window.getSelection().anchorOffset,\n        })\n      })\n    }\n\n    if (updated && (debug.enabled || debug.update.enabled)) {\n      debug('updateSelection', { selection, native, activeElement })\n\n      debug.update('updateSelection:applied', {\n        selection: selection.toJSON(),\n        native: {\n          anchorOffset: native.anchorOffset,\n          focusOffset: native.focusOffset,\n        },\n      })\n    }\n  }\n\n  /**\n   * Check if an event `target` is fired from within the contenteditable\n   * element. This should be false for edits happening in non-contenteditable\n   * children, such as void nodes and other nested Slate editors.\n   *\n   * @param {Element} target\n   * @return {Boolean}\n   */\n\n  isInEditor = target => {\n    let el\n\n    try {\n      // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n      // have .closest and it crashes.\n      if (target.nodeType === 8) {\n        return false\n      }\n\n      // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n      // `target` is a text node use its parent node for check.\n      el = target.nodeType === 3 ? target.parentNode : target\n    } catch (err) {\n      // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n      // originating from an internal \"restricted\" element (e.g. a stepper\n      // arrow on a number input)\n      // see github.com/ianstormtaylor/slate/issues/1819\n      if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n        return false\n      }\n\n      throw err\n    }\n\n    return (\n      el.isContentEditable &&\n      (el === this.ref.current ||\n        el.closest(SELECTORS.EDITOR) === this.ref.current)\n    )\n  }\n\n  /**\n   * On `event` with `handler`.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  onEvent(handler, event) {\n    debug('onEvent', handler)\n\n    const nativeEvent = event.nativeEvent || event\n    const isUndoRedo =\n      event.type === 'keydown' &&\n      (Hotkeys.isUndo(nativeEvent) || Hotkeys.isRedo(nativeEvent))\n\n    // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n    // programmatically while updating selection.\n    if (\n      (this.tmp.isUpdatingSelection || isUndoRedo) &&\n      (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')\n    ) {\n      return\n    }\n\n    // COMPAT: There are situations where a select event will fire with a new\n    // native selection that resolves to the same internal position. In those\n    // cases we don't need to trigger any changes, since our internal model is\n    // already up to date, but we do want to update the native selection again\n    // to make sure it is in sync. (2017/10/16)\n    //\n    // ANDROID: The updateSelection causes issues in Android when you are\n    // at the end of a block. The selection ends up to the left of the inserted\n    // character instead of to the right. This behavior continues even if\n    // you enter more than one character. (2019/01/03)\n    if (!IS_ANDROID && handler === 'onSelect') {\n      const { editor } = this.props\n      const { value } = editor\n      const { selection } = value\n      const domSelection = window.getSelection()\n      const range = editor.findRange(domSelection)\n\n      if (range && range.equals(selection.toRange())) {\n        this.updateSelection()\n        return\n      }\n    }\n\n    // Don't handle drag and drop events coming from embedded editors.\n    if (\n      handler === 'onDragEnd' ||\n      handler === 'onDragEnter' ||\n      handler === 'onDragExit' ||\n      handler === 'onDragLeave' ||\n      handler === 'onDragOver' ||\n      handler === 'onDragStart' ||\n      handler === 'onDrop'\n    ) {\n      const closest = event.target.closest(SELECTORS.EDITOR)\n\n      if (closest !== this.ref.current) {\n        return\n      }\n    }\n\n    // Some events require being in editable in the editor, so if the event\n    // target isn't, ignore them.\n    if (\n      handler === 'onBeforeInput' ||\n      handler === 'onBlur' ||\n      handler === 'onCompositionEnd' ||\n      handler === 'onCompositionUpdate' ||\n      handler === 'onCompositionStart' ||\n      handler === 'onCopy' ||\n      handler === 'onCut' ||\n      handler === 'onFocus' ||\n      handler === 'onInput' ||\n      handler === 'onKeyDown' ||\n      handler === 'onKeyUp' ||\n      handler === 'onPaste' ||\n      handler === 'onSelect'\n    ) {\n      if (!this.isInEditor(event.target)) {\n        return\n      }\n    }\n\n    this.props.onEvent(handler, event)\n  }\n\n  /**\n   * On native `selectionchange` event, trigger the `onSelect` handler. This is\n   * needed to account for React's `onSelect` being non-standard and not firing\n   * until after a selection has been released. This causes issues in situations\n   * where another change happens while a selection is being made.\n   *\n   * @param {Event} event\n   */\n\n  onNativeSelectionChange = throttle(event => {\n    if (this.props.readOnly) return\n\n    const { activeElement } = window.document\n\n    const native = window.getSelection()\n\n    debug.update('onNativeSelectionChange', {\n      anchorOffset: native.anchorOffset,\n    })\n\n    if (activeElement !== this.ref.current) return\n\n    this.tmp.nativeSelection = {\n      anchorNode: native.anchorNode,\n      anchorOffset: native.anchorOffset,\n      focusNode: native.focusNode,\n      focusOffset: native.focusOffset,\n      isCollapsed: native.isCollapsed,\n      rangeCount: native.rangeCount,\n      type: native.type,\n    }\n\n    this.props.onEvent('onSelect', event)\n  }, 100)\n\n  /**\n   * Render the editor content.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props, handlers } = this\n    const {\n      id,\n      className,\n      readOnly,\n      editor,\n      tabIndex,\n      role,\n      tagName,\n      spellCheck,\n      onContextMenu,\n    } = props\n    const { value } = editor\n    const Container = tagName\n    const { document } = value\n\n    const style = {\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word',\n      // COMPAT: In iOS, a formatting menu with bold, italic and underline\n      // buttons is shown which causes our internal value to get out of sync in\n      // weird ways. This hides that. (2016/06/21)\n      ...(readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }),\n      // Allow for passed-in styles to override anything.\n      ...props.style,\n    }\n\n    // console.log('rerender content', this.tmp.contentKey, document.text)\n\n    debug('render', { props })\n    debug.update('render', this.tmp.contentKey, document.text)\n\n    this.props.onEvent('onRender')\n\n    const data = {\n      [DATA_ATTRS.EDITOR]: true,\n      [DATA_ATTRS.KEY]: document.key,\n    }\n\n    const domProps = omit(this.props, Object.keys(Content.__propTypes))\n\n    return (\n      <Container\n        {...domProps}\n        key={this.tmp.contentKey}\n        {...handlers}\n        {...data}\n        ref={this.setRef}\n        contentEditable={readOnly ? null : true}\n        suppressContentEditableWarning\n        id={id}\n        className={className}\n        autoCorrect={props.autoCorrect ? 'on' : 'off'}\n        spellCheck={spellCheck}\n        style={style}\n        role={readOnly ? null : role || 'textbox'}\n        tabIndex={tabIndex}\n        onContextMenu={onContextMenu}\n        // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n\n        // just the existence of the flag is disabling the extension irrespective of its value\n        data-gramm={domProps['data-gramm'] ? undefined : false}\n      >\n        <Document editor={editor} node={document} ref={this.tmp.nodeRef} />\n      </Container>\n    )\n  }\n}\n\nfunction safelyFindDOMRange(editor, selection) {\n  try {\n    return editor.findDOMRange(selection)\n  } catch (e) {\n    console.error(e)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Content\n","import EVENT_HANDLERS from '../../constants/event-handlers'\n\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nconst PROPS = [\n  ...EVENT_HANDLERS,\n  'commands',\n  'decorateNode',\n  'queries',\n  'renderAnnotation',\n  'renderBlock',\n  'renderDecoration',\n  'renderDocument',\n  'renderEditor',\n  'renderInline',\n  'renderMark',\n  'schema',\n]\n\n/**\n * The top-level editor props in a plugin.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction EditorPropsPlugin(options = {}) {\n  const plugin = PROPS.reduce((memo, prop) => {\n    if (prop in options) memo[prop] = options[prop]\n    return memo\n  }, {})\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default EditorPropsPlugin\n","import React from 'react'\n\n/**\n * The default rendering behavior for the React plugin.\n *\n * @return {Object}\n */\n\nfunction Rendering() {\n  return {\n    decorateNode() {\n      return []\n    },\n\n    renderAnnotation({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n\n    renderBlock({ attributes, children }) {\n      return (\n        <div {...attributes} style={{ position: 'relative' }}>\n          {children}\n        </div>\n      )\n    },\n\n    renderDecoration({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n\n    renderDocument({ children }) {\n      return children\n    },\n\n    renderEditor({ children }) {\n      return children\n    },\n\n    renderInline({ attributes, children }) {\n      return (\n        <span {...attributes} style={{ position: 'relative' }}>\n          {children}\n        </span>\n      )\n    },\n\n    renderMark({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default Rendering\n","import SELECTORS from '../constants/selectors'\n\nexport default function safelyGetParentKeyNode(node) {\n  if (node == null) return null\n\n  if (node.closest == null) node = node.parentElement\n  if (node.hasAttribute(SELECTORS.KEY)) return node\n  return node.closest(SELECTORS.KEY)\n}\n","import { Block, Range, Text } from 'slate'\nimport safelyGetParentKeyNode from './safely-get-parent-key-node'\nimport DATA_ATTRS from '../constants/data-attributes'\n\nexport default function sanitizeDomOnError(editor, domNode, fn) {\n  try {\n    return { failed: false, value: fn() }\n  } catch (e) {\n    console.warn('Safely handling caught error, reconciling dom', e)\n\n    // Woo!  So, if we get here, something has gone horribly wrong and the browser has modified the dom in a way\n    // that slate can no longer understand.  So, in this event, we are going to replace the entire line (which changes\n    // the react key and forces react to re-build the dom), and this will get everything back into a working state\n    // hopefully.\n    const domElement = safelyGetParentKeyNode(domNode)\n    if (domElement == null) return { failed: true }\n\n    const key = domElement.getAttribute(DATA_ATTRS.KEY)\n    const slateNode = editor.value.document.getNode(key)\n    if (slateNode == null) return { failed: true }\n\n    const blockNode =\n      slateNode.object === 'block'\n        ? slateNode\n        : editor.value.document.getClosestBlock(slateNode.key)\n    if (blockNode == null) return { failed: true }\n\n    const lineIndex = editor.value.document.nodes.indexOf(blockNode)\n    const selection = window.getSelection()\n\n    if (\n      selection != null &&\n      selection.isCollapsed &&\n      blockNode === slateNode &&\n      lineIndex >= 0 &&\n      domElement.tagName === 'DIV' &&\n      domElement.childNodes.length === 1 &&\n      (domElement.childNodes[0] === selection.anchorNode ||\n        domElement === selection.anchorNode)\n    ) {\n      console.log('    replacing entire line via dom text')\n\n      editor.replaceNodeByKey(\n        blockNode.key,\n        Block.create({\n          type: 'line',\n          nodes: [Text.create({ text: domElement.textContent })],\n        })\n      )\n\n      const newNode = editor.value.document.nodes.get(lineIndex)\n      const textNode = newNode.nodes.first()\n      const point = { key: textNode.key, offset: selection.anchorOffset }\n      editor.select(Range.create({ anchor: point, focus: point }))\n    } else {\n      console.log('    replacing entire line')\n      editor.replaceNodeByKey(blockNode.key, Block.create(blockNode.toJSON()))\n    }\n\n    return { failed: true }\n  }\n}\n","import sanitizeDomOnError from '../../utils/sanitize-dom-on-error'\n\n/**\n * Takes a `node`, find the matching `domNode` and uses it to set the text\n * in the `node`.\n *\n * @param {Editor} editor\n * @param {Node} node\n */\n\nfunction reconcileNode(editor, node) {\n  const { value } = editor\n  const { document, selection } = value\n  const path = document.getPath(node.key)\n\n  const domElement = editor.findDOMNode(path)\n  const block = document.getClosestBlock(path)\n\n  // Get text information\n  const { text } = node\n  let { textContent: domText } = domElement\n\n  const isLastNode = block.nodes.last() === node\n  const lastChar = domText.charAt(domText.length - 1)\n\n  // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n  // we will have added another new line in <Leaf>'s render method to account\n  // for browsers collapsing a single trailing new lines, so remove it.\n  if (isLastNode && lastChar === '\\n') {\n    domText = domText.slice(0, -1)\n  }\n\n  // If the text is no different, abort.\n  // Ignore all zero-width spaces here.  There will definitely be some in the dom\n  // and we don't want those to make slate thing that the dom does not match the slate AST:\n  if (text.replace(/[\\uFEFF\\b]/g, '') === domText.replace(/[\\uFEFF\\b]/g, ''))\n    return\n\n  let entire = selection.moveAnchorTo(path, 0).moveFocusTo(path, text.length)\n\n  entire = document.resolveRange(entire)\n\n  console.warn('!!  Forced to reconcile dom node :((')\n\n  // Change the current value to have the leaf's text replaced.\n  editor.insertTextAtRange(\n    entire,\n    domText.replace(/[\\uFEFF\\b]/g, ''),\n    node.marks\n  )\n  return\n}\n\n/**\n * Takes text from the `domNode` and uses it to set the text in the matching\n * `node` in Slate.\n *\n * @param {Editor} editor\n * @param {DOMNode} domNode\n */\n\nexport function reconcileDOMNode(editor, domNode) {\n  return sanitizeDomOnError(editor, domNode, () => {\n    const domElement = domNode.parentElement.closest('[data-key]')\n    const node = editor.findNode(domElement)\n    reconcileNode(editor, node)\n  }).value\n}\n\n/**\n * A set of commands for the React plugin.\n *\n * @return {Object}\n */\n\nfunction CommandsPlugin() {\n  return {\n    commands: {\n      reconcileNode,\n      reconcileDOMNode,\n    },\n  }\n}\n\nexport default CommandsPlugin\n","import getWindow from 'get-window'\nimport { PathUtils } from 'slate'\n\nimport DATA_ATTRS from '../../constants/data-attributes'\nimport SELECTORS from '../../constants/selectors'\n\n/**\n * A set of queries for the React plugin.\n *\n * @return {Object}\n */\n\nfunction QueriesPlugin() {\n  /**\n   * Find the native DOM element for a node at `path`.\n   *\n   * @param {Editor} editor\n   * @param {Array|List} path\n   * @return {DOMNode|Null}\n   */\n\n  function findDOMNode(editor, path) {\n    path = PathUtils.create(path)\n    const content = editor.tmp.contentRef.current\n\n    if (!content) {\n      return null\n    }\n\n    if (!path.size) {\n      return content.ref.current || null\n    }\n\n    const search = (instance, p) => {\n      if (!instance) {\n        return null\n      }\n\n      if (!p.size) {\n        if (instance.ref) {\n          return instance.ref.current || null\n        } else {\n          return instance || null\n        }\n      }\n\n      const index = p.first()\n      const rest = p.rest()\n      const ref = instance.tmp.nodeRefs[index]\n      return search(ref, rest)\n    }\n\n    const document = content.tmp.nodeRef.current\n    const el = search(document, path)\n    return el\n  }\n\n  /**\n   * Find a native DOM selection point from a Slate `point`.\n   *\n   * @param {Editor} editor\n   * @param {Point} point\n   * @return {Object|Null}\n   */\n\n  function findDOMPoint(editor, point) {\n    const el = findDOMNode(editor, point.path)\n    let start = 0\n\n    if (!el) {\n      return null\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering to its\n    // direct text and zero-width spans. (We have to filter out any other siblings\n    // that may have been rendered alongside them.)\n    const texts = Array.from(\n      el.querySelectorAll(`${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`)\n    )\n\n    for (const text of texts) {\n      const node = text.childNodes[0]\n      const domLength = node.textContent.length\n      let slateLength = domLength\n\n      if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n        slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10)\n      }\n\n      const end = start + slateLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(domLength, Math.max(0, point.offset - start))\n        return { node, offset }\n      }\n\n      start = end\n    }\n\n    return null\n  }\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * @param {Editor} editor\n   * @param {Range} range\n   * @return {DOMRange|Null}\n   */\n\n  function findDOMRange(editor, range) {\n    const { anchor, focus, isBackward, isCollapsed } = range\n    const domAnchor = findDOMPoint(editor, anchor)\n    const domFocus = isCollapsed ? domAnchor : findDOMPoint(editor, focus)\n\n    if (!domAnchor || !domFocus) {\n      return null\n    }\n\n    const window = getWindow(domAnchor.node)\n    const r = window.document.createRange()\n    const start = isBackward ? domFocus : domAnchor\n    const end = isBackward ? domAnchor : domFocus\n    r.setStart(start.node, start.offset)\n    r.setEnd(end.node, end.offset)\n    return r\n  }\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findNode(editor, element) {\n    const path = findPath(editor, element)\n\n    if (!path) {\n      return null\n    }\n\n    const { value } = editor\n    const { document } = value\n    const node = document.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the target range from a DOM `event`.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Range}\n   */\n\n  function findEventRange(editor, event) {\n    if (event.nativeEvent) {\n      event = event.nativeEvent\n    }\n\n    const { clientX: x, clientY: y, target } = event\n    if (x == null || y == null) return null\n\n    const { value } = editor\n    const { document } = value\n    const path = findPath(editor, event.target)\n    if (!path) return null\n\n    const node = document.getNode(path)\n\n    // If the drop target is inside a void node, move it into either the next or\n    // previous node, depending on which side the `x` and `y` coordinates are\n    // closest to.\n    if (editor.isVoid(node)) {\n      const rect = target.getBoundingClientRect()\n      const isPrevious =\n        node.object === 'inline'\n          ? x - rect.left < rect.left + rect.width - x\n          : y - rect.top < rect.top + rect.height - y\n\n      const range = document.createRange()\n      const move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode'\n      const entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](\n        path\n      )\n\n      if (entry) {\n        return range[move](entry)\n      }\n\n      return null\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    const window = getWindow(target)\n    let native\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (window.document.caretRangeFromPoint) {\n      native = window.document.caretRangeFromPoint(x, y)\n    } else if (window.document.caretPositionFromPoint) {\n      const position = window.document.caretPositionFromPoint(x, y)\n      native = window.document.createRange()\n      native.setStart(position.offsetNode, position.offset)\n      native.setEnd(position.offsetNode, position.offset)\n    } else if (window.document.body.createTextRange) {\n      // COMPAT: In IE, `caretRangeFromPoint` and\n      // `caretPositionFromPoint` don't exist. (2018/07/11)\n      native = window.document.body.createTextRange()\n\n      try {\n        native.moveToPoint(x, y)\n      } catch (error) {\n        // IE11 will raise an `unspecified error` if `moveToPoint` is\n        // called during a dropEvent.\n        return null\n      }\n    }\n\n    // Resolve a Slate range from the DOM range.\n    const range = findRange(editor, native)\n    return range\n  }\n\n  /**\n   * Find the path of a native DOM `element` by searching React refs.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findPath(editor, element) {\n    const content = editor.tmp.contentRef.current\n    let nodeElement = element\n\n    // If element does not have a key, it is likely a string or\n    // mark, return the closest parent Node that can be looked up.\n    if (!nodeElement.hasAttribute(DATA_ATTRS.KEY)) {\n      nodeElement = nodeElement.closest(SELECTORS.KEY)\n    }\n\n    const key =\n      nodeElement == null ? null : nodeElement.getAttribute(DATA_ATTRS.KEY)\n\n    if (!nodeElement || !key) {\n      return null\n    }\n\n    if (nodeElement === content.ref.current) {\n      return PathUtils.create([])\n    }\n\n    const docPath = editor.value.document.getPath(key)\n    if (docPath) return docPath\n\n    const search = (instance, p) => {\n      if (nodeElement === instance) {\n        return p\n      }\n\n      if (!instance.ref) {\n        return null\n      }\n\n      if (nodeElement === instance.ref.current) {\n        return p\n      }\n\n      // If there's no `tmp` then we're at a leaf node without success.\n      if (!instance.tmp) {\n        return null\n      }\n\n      const { nodeRefs } = instance.tmp\n      const keys = Object.keys(nodeRefs)\n\n      for (const i of keys) {\n        const ref = nodeRefs[i]\n        const n = parseInt(i, 10)\n        const path = search(ref, [...p, n])\n\n        if (path) {\n          return path\n        }\n      }\n\n      return null\n    }\n\n    const document = content.tmp.nodeRef.current\n    const path = search(document, [])\n\n    if (!path) {\n      return null\n    }\n\n    return PathUtils.create(path)\n  }\n\n  /**\n   * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n   *\n   * @param {Editor} editor\n   * @param {Element} nativeNode\n   * @param {Number} nativeOffset\n   * @return {Point}\n   */\n\n  function findPoint(editor, nativeNode, nativeOffset) {\n    const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n      nativeNode,\n      nativeOffset\n    )\n\n    const window = getWindow(nativeNode)\n    const { parentNode } = nearestNode\n    let leafNode = parentNode.closest(SELECTORS.LEAF)\n    let textNode\n    let offset\n    let node\n\n    // Calculate how far into the text node the `nearestNode` is, so that we can\n    // determine what the offset relative to the text node is.\n    if (leafNode) {\n      textNode = leafNode.closest(SELECTORS.TEXT)\n      const range = window.document.createRange()\n      range.setStart(textNode, 0)\n      range.setEnd(nearestNode, nearestOffset)\n      const contents = range.cloneContents()\n      const zeroWidths = contents.querySelectorAll(SELECTORS.ZERO_WIDTH)\n\n      Array.from(zeroWidths).forEach(el => {\n        el.parentNode.removeChild(el)\n      })\n\n      // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n      // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n      // its cursor to match the native position. Use textContent.length instead.\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n      offset = contents.textContent.length\n      node = textNode\n    } else {\n      // For void nodes, the element with the offset key will be a cousin, not an\n      // ancestor, so find it by going down from the nearest void parent.\n      const voidNode = parentNode.closest(SELECTORS.VOID)\n\n      if (!voidNode) {\n        return null\n      }\n\n      leafNode = voidNode.querySelector(SELECTORS.LEAF)\n\n      if (!leafNode) {\n        return null\n      }\n\n      textNode = leafNode.closest(SELECTORS.TEXT)\n      node = leafNode\n      offset = node.textContent.length\n    }\n\n    // COMPAT: If the parent node is a Slate zero-width space, this is because the\n    // text node should have no characters. However, during IME composition the\n    // ASCII characters will be prepended to the zero-width space, so subtract 1\n    // from the offset to account for the zero-width space character.\n    if (\n      offset === node.textContent.length &&\n      parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n    ) {\n      offset--\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another, the\n    // select event fires twice, once for the old editor's `element` first, and\n    // then afterwards for the correct `element`. (2017/03/03)\n    const path = findPath(editor, textNode)\n\n    if (!path) {\n      return null\n    }\n\n    const { value } = editor\n    const { document } = value\n    const point = document.createPoint({ path, offset })\n    return point\n  }\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domRange\n   * @return {Range}\n   */\n\n  function findRange(editor, domRange) {\n    const el = domRange.anchorNode || domRange.startContainer\n\n    if (!el) {\n      return null\n    }\n\n    const window = getWindow(el)\n\n    // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\n    // into something that looks like a DOM `Selection` instead.\n    if (\n      domRange instanceof window.Range ||\n      (window.StaticRange && domRange instanceof window.StaticRange)\n    ) {\n      domRange = {\n        anchorNode: domRange.startContainer,\n        anchorOffset: domRange.startOffset,\n        focusNode: domRange.endContainer,\n        focusOffset: domRange.endOffset,\n      }\n    }\n\n    const {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset,\n      isCollapsed,\n    } = domRange\n    const { value } = editor\n    const anchor = findPoint(editor, anchorNode, anchorOffset)\n    const focus = isCollapsed\n      ? anchor\n      : findPoint(editor, focusNode, focusOffset)\n\n    if (!anchor || !focus) {\n      return null\n    }\n\n    const { document } = value\n    const range = document.createRange({\n      anchor,\n      focus,\n    })\n\n    return range\n  }\n\n  /**\n   * Find a Slate selection from a DOM selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domSelection\n   * @return {Range}\n   */\n\n  function findSelection(editor, domSelection) {\n    const { value } = editor\n    const { document } = value\n\n    // If there are no ranges, the editor was blurred natively.\n    if (!domSelection.rangeCount) {\n      return null\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    let range = findRange(editor, domSelection)\n\n    if (!range) {\n      return null\n    }\n\n    const { anchor, focus } = range\n    const anchorText = document.getNode(anchor.path)\n    const focusText = document.getNode(focus.path)\n    const anchorInline = document.getClosestInline(anchor.path)\n    const focusInline = document.getClosestInline(focus.path)\n    const focusBlock = document.getClosestBlock(focus.path)\n    const anchorBlock = document.getClosestBlock(anchor.path)\n\n    // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n    if (\n      anchorBlock &&\n      !editor.isVoid(anchorBlock) &&\n      anchor.offset === 0 &&\n      focusBlock &&\n      editor.isVoid(focusBlock) &&\n      focus.offset !== 0\n    ) {\n      range = range.setFocus(focus.setOffset(0))\n    }\n\n    // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n    if (\n      anchorInline &&\n      !editor.isVoid(anchorInline) &&\n      anchor.offset === anchorText.text.length\n    ) {\n      const block = document.getClosestBlock(anchor.path)\n      const depth = document.getDepth(block.key)\n      const relativePath = PathUtils.drop(anchor.path, depth)\n      const [next] = block.texts({ path: relativePath })\n\n      if (next) {\n        const [, nextPath] = next\n        const absolutePath = anchor.path.slice(0, depth).concat(nextPath)\n        range = range.moveAnchorTo(absolutePath, 0)\n      }\n    }\n\n    if (\n      focusInline &&\n      !editor.isVoid(focusInline) &&\n      focus.offset === focusText.text.length\n    ) {\n      const block = document.getClosestBlock(focus.path)\n      const depth = document.getDepth(block.key)\n      const relativePath = PathUtils.drop(focus.path, depth)\n      const [next] = block.texts({ path: relativePath })\n\n      if (next) {\n        const [, nextPath] = next\n        const absolutePath = focus.path.slice(0, depth).concat(nextPath)\n        range = range.moveFocusTo(absolutePath, 0)\n      }\n    }\n\n    let selection = document.createSelection(range)\n\n    // COMPAT: Ensure that the `isFocused` argument is set.\n    selection = selection.setIsFocused(true)\n\n    // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\n    // selection's marks were. They will be cleared automatically by the\n    // `select` command if the selection moves.\n    selection = selection.set('marks', value.selection.marks)\n\n    return selection\n  }\n\n  return {\n    queries: {\n      findDOMNode,\n      findDOMPoint,\n      findDOMRange,\n      findEventRange,\n      findNode,\n      findPath,\n      findPoint,\n      findRange,\n      findSelection,\n    },\n  }\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType === 8 ||\n    (child.nodeType === 1 && child.childNodes.length === 0) ||\n    (child.nodeType === 1 && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction === 'forward') i++\n    if (direction === 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default QueriesPlugin\n","/**\n * Returns the number of characters that are the same at the beginning of the\n * String.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nfunction getDiffStart(prev, next) {\n  const length = Math.min(prev.length, next.length)\n\n  for (let i = 0; i < length; i++) {\n    if (prev.charAt(i) !== next.charAt(i)) return i\n  }\n\n  if (prev.length !== next.length) return length\n  return null\n}\n\n/**\n * Returns the number of characters that are the same at the end of the String\n * up to `max`. Max prevents double-counting characters when there are\n * multiple duplicate characters around the diff area.\n *\n * @param {String} prev\n * @param {String} next\n * @param {Number} max\n */\n\nfunction getDiffEnd(prev, next, max) {\n  const prevLength = prev.length\n  const nextLength = next.length\n  const length = Math.min(prevLength, nextLength, max)\n\n  for (let i = 0; i < length; i++) {\n    const prevChar = prev.charAt(prevLength - i - 1)\n    const nextChar = next.charAt(nextLength - i - 1)\n    if (prevChar !== nextChar) return i\n  }\n\n  if (prev.length !== next.length) return length\n  return null\n}\n\n/**\n * Takes two strings and returns an object representing two offsets. The\n * first, `start` represents the number of characters that are the same at\n * the front of the String. The `end` represents the number of characters\n * that are the same at the end of the String.\n *\n * Returns null if they are identical.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nfunction getDiffOffsets(prev, next) {\n  if (prev === next) return null\n  const start = getDiffStart(prev, next)\n  const maxEnd = Math.min(prev.length - start, next.length - start)\n  const end = getDiffEnd(prev, next, maxEnd)\n  return { start, end, total: start + end }\n}\n\n/**\n * Takes a text string and returns a slice from the string at the given offses\n *\n * @param {String} text\n * @param {Object} offsets\n */\n\nfunction sliceText(text, offsets) {\n  return text.slice(offsets.start, text.length - offsets.end)\n}\n\n/**\n * Takes two strings and returns a smart diff that can be used to describe the\n * change in a way that can be used as operations like inserting, removing or\n * replacing text.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nexport default function diff(prev, next) {\n  const offsets = getDiffOffsets(prev, next)\n  if (offsets == null) return null\n  const insertText = sliceText(next, offsets)\n  const removeText = sliceText(prev, offsets)\n  return {\n    start: offsets.start,\n    end: prev.length - offsets.end,\n    cursor: offsets.start + insertText.length,\n    insertText,\n    removeText,\n  }\n}\n","import Debug from 'debug'\nimport getWindow from 'get-window'\nimport ReactDOM from 'react-dom'\nimport diffText from './diff-text'\n\n/**\n * @type {Debug}\n */\n\nconst debug = Debug('slate:composition-manager')\n\n/**\n * Unicode String for a ZERO_WIDTH_SPACE\n *\n * @type {String}\n */\n\nconst ZERO_WIDTH_SPACE = String.fromCharCode(65279)\n\n/**\n * https://github.com/facebook/draft-js/commit/cda13cb8ff9c896cdb9ff832d1edeaa470d3b871\n */\n\nconst flushControlled = ReactDOM.unstable_flushControlled\n\nfunction renderSync(editor, fn) {\n  flushControlled(() => {\n    fn()\n    editor.controller.flush()\n  })\n}\n\n/**\n * Takes text from a dom node and an offset within that text and returns an\n * object with fixed text and fixed offset which removes zero width spaces\n * and adjusts the offset.\n *\n * Optionally, if an `isLastNode` argument is passed in, it will also remove\n * a trailing newline.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Boolean} isLastNode\n */\n\nfunction fixTextAndOffset(prevText, prevOffset = 0, isLastNode = false) {\n  let nextOffset = prevOffset\n  let nextText = prevText\n  let index = 0\n\n  while (index !== -1) {\n    index = nextText.indexOf(ZERO_WIDTH_SPACE, index)\n    if (index === -1) break\n    if (nextOffset > index) nextOffset--\n    nextText = `${nextText.slice(0, index)}${nextText.slice(index + 1)}`\n  }\n\n  // remove the last newline if we are in the last node of a block\n  const lastChar = nextText.charAt(nextText.length - 1)\n\n  if (isLastNode && lastChar === '\\n') {\n    nextText = nextText.slice(0, -1)\n  }\n\n  const maxOffset = nextText.length\n\n  if (nextOffset > maxOffset) nextOffset = maxOffset\n  return { text: nextText, offset: nextOffset }\n}\n\n/**\n * Based loosely on:\n *\n * https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js\n * https://github.com/ProseMirror/prosemirror-view/blob/master/src/domobserver.js\n *\n * But is an analysis mainly for `backspace` and `enter` as we handle\n * compositions as a single operation.\n *\n * @param {} element\n */\n\nfunction CompositionManager(editor) {\n  /**\n   * A MutationObserver that flushes to the method `flush`\n   *\n   * @type {MutationObserver}\n   */\n\n  const observer = new window.MutationObserver(flush)\n\n  let win = null\n\n  /**\n   * Object that keeps track of the most recent state\n   *\n   * @type {Range}\n   */\n\n  const last = {\n    rootEl: null, // root element that MutationObserver is attached to\n    diff: null, // last text node diff between Slate and DOM\n    range: null, // last range selected\n    domNode: null, // last DOM node the cursor was in\n  }\n\n  /**\n   * Connect the MutationObserver to a specific editor root element\n   */\n\n  function connect() {\n    debug('connect', { rootEl })\n\n    const rootEl = editor.findDOMNode([])\n\n    if (last.rootEl === rootEl) return\n\n    debug('connect:run')\n\n    win = getWindow(rootEl)\n\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true,\n    })\n  }\n\n  function disconnect() {\n    debug('disconnect')\n    observer.disconnect()\n    last.rootEl = null\n  }\n\n  function clearDiff() {\n    debug('clearDIff')\n    last.diff = null\n  }\n\n  /**\n   * Clear the `last` properties related to an action only\n   */\n\n  function clearAction() {\n    debug('clearAction')\n    last.diff = null\n    last.domNode = null\n  }\n\n  /**\n   * Apply the last `diff`\n   *\n   * We don't want to apply the `diff` at the time it is created because we\n   * may be in a composition. There are a few things that trigger the applying\n   * of the saved diff. Sometimeson its own and sometimes immediately before\n   * doing something else with the Editor.\n   *\n   * - `onCompositionEnd` event\n   * - `onSelect` event only when the user has moved into a different node\n   * - The user hits `enter`\n   * - The user hits `backspace` and removes an inline node\n   * - The user hits `backspace` and merges two blocks\n   */\n\n  function applyDiff() {\n    debug('applyDiff')\n    const { diff } = last\n    if (diff == null) return\n    debug('applyDiff:run')\n    const { document } = editor.value\n\n    let entire = editor.value.selection\n      .moveAnchorTo(diff.path, diff.start)\n      .moveFocusTo(diff.path, diff.end)\n\n    entire = document.resolveRange(entire)\n\n    editor.insertTextAtRange(entire, diff.insertText)\n  }\n\n  /**\n   * Handle `enter` that splits block\n   */\n\n  function splitBlock() {\n    debug('splitBlock')\n\n    renderSync(editor, () => {\n      applyDiff()\n\n      if (last.range) {\n        editor.select(last.range)\n      } else {\n        debug('splitBlock:NO-SELECTION')\n      }\n\n      editor\n        .splitBlock()\n        .focus()\n        .restoreDOM()\n\n      clearAction()\n    })\n  }\n\n  /**\n   * Handle `backspace` that merges blocks\n   */\n\n  function mergeBlock() {\n    debug('mergeBlock')\n\n    /**\n     * The delay is required because hitting `enter`, `enter` then `backspace`\n     * in a word results in the cursor being one position to the right in\n     * Android 9.\n     *\n     * Slate sets the position to `0` and we even check it immediately after\n     * setting it and it is correct, but somewhere Android moves it to the right.\n     *\n     * This happens only when using the virtual keyboard. Hitting enter on a\n     * hardware keyboard does not trigger this bug.\n     *\n     * The call to `focus` is required because when we switch examples then\n     * merge a block, we lose focus in Android 9 (possibly others).\n     */\n\n    win.requestAnimationFrame(() => {\n      renderSync(editor, () => {\n        applyDiff()\n\n        editor\n          .select(last.range)\n          .deleteBackward()\n          .focus()\n          .restoreDOM()\n\n        clearAction()\n      })\n    })\n  }\n\n  /**\n   * The requestId used to the save selection\n   *\n   * @type {Any}\n   */\n\n  let onSelectTimeoutId = null\n\n  let bufferedMutations = []\n  let startActionFrameId = null\n  let isFlushing = false\n\n  /**\n   * Mark the beginning of an action. The action happens when the\n   * `requestAnimationFrame` expires.\n   *\n   * If `startAction` is called again, it pushes the `action` to a new\n   * `requestAnimationFrame` and cancels the old one.\n   */\n\n  function startAction() {\n    if (onSelectTimeoutId) {\n      window.cancelAnimationFrame(onSelectTimeoutId)\n      onSelectTimeoutId = null\n    }\n\n    isFlushing = true\n\n    if (startActionFrameId) window.cancelAnimationFrame(startActionFrameId)\n\n    startActionFrameId = window.requestAnimationFrame(() => {\n      if (bufferedMutations.length > 0) {\n        flushAction(bufferedMutations)\n      }\n\n      startActionFrameId = null\n      bufferedMutations = []\n      isFlushing = false\n    })\n  }\n\n  /**\n   * Handle MutationObserver flush\n   *\n   * @param {MutationList} mutations\n   */\n\n  function flush(mutations) {\n    debug('flush')\n    bufferedMutations.push(...mutations)\n    startAction()\n  }\n\n  /**\n   * Handle a `requestAnimationFrame` long batch of mutations.\n   *\n   * @param {Array} mutations\n   */\n\n  function flushAction(mutations) {\n    debug('flushAction', mutations.length, mutations)\n\n    // If there is an expanded collection, delete it\n    if (last.range && !last.range.isCollapsed) {\n      renderSync(editor, () => {\n        editor\n          .select(last.range)\n          .deleteBackward()\n          .focus()\n          .restoreDOM()\n      })\n      return\n    }\n\n    if (mutations.length > 1) {\n      // check if one of the mutations matches the signature of an `enter`\n      // which we use to signify a `splitBlock`\n      const splitBlockMutation = mutations.find(m => {\n        if (m.type !== 'childList') return false\n        if (m.addedNodes.length === 0) return false\n        const addedNode = m.addedNodes[0]\n\n        // If a text node is created anywhere with a newline in it, it's an\n        // enter\n        if (\n          addedNode.nodeType === window.Node.TEXT_NODE &&\n          addedNode.textContent === '\\n'\n        )\n          return true\n\n        // If an element is created with a key that matches a block in our\n        // document, that means the mutation is splitting an existing block\n        // by creating a new element with the same key.\n        if (addedNode.nodeType !== window.Node.ELEMENT_NODE) return false\n        const dataset = addedNode.dataset\n        const key = dataset.key\n        if (key == null) return false\n        const block = editor.value.document.getClosestBlock(key)\n        return !!block\n      })\n\n      if (splitBlockMutation) {\n        splitBlock()\n        return\n      }\n    }\n\n    // If we haven't matched a more specific mutation already, these general\n    // mutation catchers will try and determine what the user was trying to\n    // do.\n\n    const firstMutation = mutations[0]\n\n    if (firstMutation.type === 'characterData') {\n      resolveDOMNode(firstMutation.target.parentNode)\n    } else if (firstMutation.type === 'childList') {\n      if (firstMutation.removedNodes.length > 0) {\n        if (mutations.length === 1) {\n          removeNode(firstMutation.removedNodes[0])\n        } else {\n          mergeBlock()\n        }\n      } else if (firstMutation.addedNodes.length > 0) {\n        splitBlock()\n      }\n    }\n  }\n\n  /**\n   * Takes a DOM Node and resolves it against Slate's Document.\n   *\n   * Saves the changes to `last.diff` which can be applied later using\n   * `applyDiff()`\n   *\n   * @param {DOMNode} domNode\n   */\n\n  function resolveDOMNode(domNode) {\n    debug('resolveDOMNode')\n\n    const { value } = editor\n    const { document } = value\n\n    const dataElement = domNode.closest(`[data-key]`)\n    const key = dataElement.dataset.key\n    const path = document.getPath(key)\n    const block = document.getClosestBlock(key)\n    const node = document.getDescendant(key)\n    const prevText = node.text\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    const isLastNode = block.nodes.last() === node\n\n    const fix = fixTextAndOffset(domNode.textContent, 0, isLastNode)\n\n    const nextText = fix.text\n\n    // If the text is no different, there is no diff.\n    if (nextText === prevText) {\n      last.diff = null\n      return\n    }\n\n    const diff = diffText(prevText, nextText)\n\n    last.diff = {\n      path,\n      start: diff.start,\n      end: diff.end,\n      insertText: diff.insertText,\n    }\n\n    debug('resolveDOMNode:diff', last.diff)\n  }\n\n  /**\n   * Remove an Inline DOM Node.\n   *\n   * Happens when you delete the last character in an Inline DOM Node\n   */\n\n  function removeNode(domNode) {\n    debug('removeNode')\n    if (domNode.nodeType !== window.Node.ELEMENT_NODE) return\n    const { value } = editor\n    const { document, selection } = value\n    const node = editor.findNode(domNode)\n    const nodeSelection = document.resolveRange(\n      selection.moveToRangeOfNode(node)\n    )\n\n    renderSync(editor, () => {\n      editor\n        .select(nodeSelection)\n        .delete()\n        .restoreDOM()\n    })\n  }\n\n  /**\n   * handle `onCompositionStart`\n   */\n\n  function onCompositionStart() {\n    debug('onCompositionStart')\n  }\n\n  /**\n   * handle `onCompositionEnd`\n   */\n\n  function onCompositionEnd() {\n    debug('onCompositionEnd')\n\n    /**\n     * The timing on the `setTimeout` with `20` ms is sensitive.\n     *\n     * It cannot use `requestAnimationFrame` because it is too short.\n     *\n     * Android 9, for example, when you type `it ` the space will first trigger\n     * a `compositionEnd` for the `it` part before the mutation for the ` `.\n     * This means that we end up with `it` if we trigger too soon because it\n     * is on the wrong value.\n     */\n\n    window.setTimeout(() => {\n      if (last.diff) {\n        debug('onCompositionEnd:applyDiff')\n\n        renderSync(editor, () => {\n          applyDiff()\n\n          const domRange = win.getSelection().getRangeAt(0)\n          const domText = domRange.startContainer.textContent\n          const offset = domRange.startOffset\n\n          const fix = fixTextAndOffset(domText, offset)\n\n          const range = editor\n            .findRange({\n              anchorNode: domRange.startContainer,\n              anchorOffset: 0,\n              focusNode: domRange.startContainer,\n              focusOffset: 0,\n              isCollapsed: true,\n            })\n            .moveTo(fix.offset)\n\n          /**\n           * We must call `restoreDOM` even though this is applying a `diff` which\n           * should not require it. But if you type `it me. no.` on a blank line\n           * with a block following it, the next line will merge with the this\n           * line. A mysterious `keydown` with `input` of backspace appears in the\n           * event stream which the user not React caused.\n           *\n           * `focus` is required as well because otherwise we lose focus on hitting\n           * `enter` in such a scenario.\n           */\n\n          editor\n            .select(range)\n            .focus()\n            .restoreDOM()\n        })\n      }\n\n      clearAction()\n    }, 20)\n  }\n\n  /**\n   * Handle `onSelect` event\n   *\n   * Save the selection after a `requestAnimationFrame`\n   *\n   * - If we're not in the middle of flushing mutations\n   * - and cancel save if a mutation runs before the `requestAnimationFrame`\n   */\n\n  function onSelect(event) {\n    debug('onSelect:try')\n\n    // Event can be Synthetic React or native. Grab only the native one so\n    // that we don't have to call `event.perist` for performance.\n    event = event.nativeEvent ? event.nativeEvent : event\n\n    window.cancelAnimationFrame(onSelectTimeoutId)\n    onSelectTimeoutId = null\n\n    // Don't capture the last selection if the selection was made during the\n    // flushing of DOM mutations. This means it is all part of one user action.\n    if (isFlushing) return\n\n    onSelectTimeoutId = window.requestAnimationFrame(() => {\n      debug('onSelect:save-selection')\n\n      const domSelection = getWindow(event.target).getSelection()\n      let range = editor.findRange(domSelection)\n\n      const anchorFix = fixTextAndOffset(\n        domSelection.anchorNode.textContent,\n        domSelection.anchorOffset\n      )\n\n      const focusFix = fixTextAndOffset(\n        domSelection.focusNode.textContent,\n        domSelection.focusOffset\n      )\n\n      if (range.anchor.offset !== anchorFix.offset) {\n        range = range.set(\n          'anchor',\n          range.anchor.set('offset', anchorFix.offset)\n        )\n      }\n\n      if (range.focus.offset !== focusFix.offset) {\n        range = range.set('focus', range.focus.set('offset', focusFix.offset))\n      }\n\n      debug('onSelect:save-data', {\n        domSelection: normalizeDOMSelection(domSelection),\n        range: range.toJS(),\n      })\n\n      // If the `domSelection` has moved into a new node, then reconcile with\n      // `applyDiff`\n      if (\n        domSelection.isCollapsed &&\n        last.node !== domSelection.anchorNode &&\n        last.diff != null\n      ) {\n        debug('onSelect:applyDiff', last.diff)\n        applyDiff()\n        editor.select(range)\n        clearAction()\n      }\n\n      last.range = range\n      last.node = domSelection.anchorNode\n    })\n  }\n\n  return {\n    clearDiff,\n    connect,\n    disconnect,\n    onKeyDown: startAction,\n    onCompositionStart,\n    onCompositionEnd,\n    onSelect,\n  }\n}\n\nfunction normalizeDOMSelection(selection) {\n  return {\n    anchorNode: selection.anchorNode,\n    anchorOffset: selection.anchorOffset,\n    focusNode: selection.focusNode,\n    focusOffset: selection.focusOffset,\n  }\n}\n\nexport default CompositionManager\n","import getWindow from 'get-window'\nimport CompositionManager from './composition-manager'\n\n/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\nfunction fixSelectionInZeroWidthBlock(window) {\n  const domSelection = window.getSelection()\n  const { anchorNode } = domSelection\n  if (anchorNode == null) return\n  const { dataset } = anchorNode.parentElement\n  const isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false\n\n  if (\n    isZeroWidth &&\n    anchorNode.textContent.length === 1 &&\n    domSelection.anchorOffset !== 0\n  ) {\n    const range = window.document.createRange()\n    range.setStart(anchorNode, 0)\n    range.setEnd(anchorNode, 0)\n    domSelection.removeAllRanges()\n    domSelection.addRange(range)\n  }\n}\n\n/**\n * Android Plugin\n *\n * @param {Editor} options.editor\n */\n\nfunction AndroidPlugin({ editor }) {\n  const observer = new CompositionManager(editor)\n\n  /**\n   * handle `onCompositionStart`\n   */\n\n  function onCompositionStart() {\n    observer.onCompositionStart()\n  }\n\n  /**\n   * handle `onCompositionEnd`\n   */\n\n  function onCompositionEnd() {\n    observer.onCompositionEnd()\n  }\n\n  /**\n   * handle `onSelect`\n   *\n   * @param {Event} event\n   */\n\n  function onSelect(event) {\n    const window = getWindow(event.target)\n    fixSelectionInZeroWidthBlock(window)\n    observer.onSelect(event)\n  }\n\n  /**\n   * handle `onComponentDidMount`\n   */\n\n  function onComponentDidMount() {\n    observer.connect()\n  }\n\n  /**\n   * handle `onComponentDidUpdate`\n   */\n\n  function onComponentDidUpdate() {\n    observer.connect()\n  }\n\n  /**\n   * handle `onComponentWillUnmount`\n   *\n   * @param {Event} event\n   */\n\n  function onComponentWillUnmount() {\n    observer.disconnect()\n  }\n\n  /**\n   * handle `onRender`\n   *\n   * @param {Event} event\n   */\n\n  function onRender() {\n    observer.disconnect()\n\n    // We don't want the `diff` from a previous render to apply to a\n    // potentially different value (e.g. when we switch examples)\n    observer.clearDiff()\n  }\n\n  return {\n    onComponentDidMount,\n    onComponentDidUpdate,\n    onComponentWillUnmount,\n    onCompositionEnd,\n    onCompositionStart,\n    onRender,\n    onSelect,\n  }\n}\n\nexport default AndroidPlugin\n","import EVENT_HANDLERS from '../../constants/event-handlers'\n\n/**\n * This plugin prevents events from going any further and is useful in dev.\n *\n * The purpose is to see how the editor events and mutations behave without\n * the noise of the editor also adding its own events and mutations.\n *\n * IMPORTANT:\n *\n * This plugin is detached (i.e. there is no way to turn it on in Slate).\n * You must hard code it into `plugins/react/index`.\n *\n * @return {Object}\n */\n\nfunction NoopPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {}\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default NoopPlugin\n","/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nexport default {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain',\n}\n","import Base64 from 'slate-base64-serializer'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { IS_IE } from 'slate-dev-environment'\nimport { Value } from 'slate'\n\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport removeAllRanges from './remove-all-ranges'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\nconst { FRAGMENT, HTML, TEXT } = TRANSFER_TYPES\n\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor, callback = () => undefined) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.'\n  )\n\n  const window = getWindow(event.target)\n  const native = window.getSelection()\n  const { value } = editor\n  const { document, fragment, selection } = value\n  const { start, end } = selection\n  const startVoid = document.getClosestVoid(start.path, editor)\n  const endVoid = document.getClosestVoid(end.path, editor)\n\n  // If the selection is collapsed, and it isn't inside a void node, abort.\n  if (native.isCollapsed && !startVoid) return\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  const encoded = Base64.serializeNode(fragment)\n  const range = native.getRangeAt(0)\n  let contents = range.cloneContents()\n  let attach = contents.childNodes[0]\n\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\n  contents.childNodes.forEach(node => {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node\n    }\n  })\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    const r = range.cloneRange()\n    const path = document.getPath(endVoid.key)\n\n    if (path) {\n      const node = editor.findDOMNode(path)\n      r.setEndAfter(node)\n      contents = r.cloneContents()\n    }\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  ;[].slice\n    .call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH))\n    .forEach(zw => {\n      const isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n'\n      zw.textContent = isNewline ? '\\n' : ''\n    })\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (attach.nodeType === 3) {\n    const span = window.document.createElement('span')\n\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre'\n\n    span.appendChild(attach)\n    contents.appendChild(span)\n    attach = span\n  }\n\n  attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded)\n\n  //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n  const valFromSelection = Value.create({ document: fragment })\n  const plainText = Plain.serialize(valFromSelection)\n\n  // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n  const div = window.document.createElement('div')\n  div.appendChild(contents)\n\n  // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault()\n    event.clipboardData.setData(TEXT, plainText)\n    event.clipboardData.setData(FRAGMENT, encoded)\n    event.clipboardData.setData(HTML, div.innerHTML)\n    callback()\n    return\n  }\n\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n  const editorEl = event.target.closest(SELECTORS.EDITOR)\n  div.setAttribute('contenteditable', true)\n  div.style.position = 'absolute'\n  div.style.left = '-9999px'\n  editorEl.appendChild(div)\n  native.selectAllChildren(div)\n\n  // Revert to the previous selection right after copying.\n  window.requestAnimationFrame(() => {\n    editorEl.removeChild(div)\n    removeAllRanges(native)\n    native.addRange(range)\n    callback()\n  })\n}\n\nexport default cloneFragment\n","import Base64 from 'slate-base64-serializer'\nimport { IS_IE } from 'slate-dev-environment'\n\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nconst { FRAGMENT, HTML, NODE, RICH, TEXT } = TRANSFER_TYPES\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nconst FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n  let fragment = getType(transfer, FRAGMENT)\n  let node = getType(transfer, NODE)\n  const html = getType(transfer, HTML)\n  const rich = getType(transfer, RICH)\n  let text = getType(transfer, TEXT)\n  let files\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(` ${DATA_ATTRS.FRAGMENT}=\"`)) {\n    const matches = FRAGMENT_MATCHER.exec(html)\n    const [full, encoded] = matches // eslint-disable-line no-unused-vars\n    if (encoded) fragment = encoded\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    const embeddedTypes = getEmbeddedTypes(text)\n\n    if (embeddedTypes[FRAGMENT]) fragment = embeddedTypes[FRAGMENT]\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE]\n    if (embeddedTypes[TEXT]) text = embeddedTypes[TEXT]\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = Base64.deserializeNode(fragment)\n  if (node) node = Base64.deserializeNode(node)\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items)\n        .map(item => (item.kind === 'file' ? item.getAsFile() : null))\n        .filter(exists => exists)\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  }\n\n  // Determine the type of the data.\n  const data = { files, fragment, html, node, rich, text }\n  data.type = getTransferType(data)\n  return data\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  const prefix = 'SLATE-DATA-EMBED::'\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return { TEXT: text }\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length))\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.')\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment'\n  if (data.node) return 'node'\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html'\n  if (data.rich && data.text) return 'text'\n\n  if (data.files && data.files.length) return 'files'\n  if (data.html) return 'html'\n  if (data.text) return 'text'\n  return 'unknown'\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT ? transfer.getData('Text') || null : null\n  }\n\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n  const types = Array.from(transfer.types)\n\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventTransfer\n","import TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nconst { TEXT } = TRANSFER_TYPES\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  const mime = TRANSFER_TYPES[type.toUpperCase()]\n\n  if (!mime) {\n    throw new Error(`Cannot set unknown transfer type \"${mime}\".`)\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n\n  try {\n    transfer.setData(mime, content)\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n    transfer.setData('text', transfer.getData('text'))\n  } catch (err) {\n    const prefix = 'SLATE-DATA-EMBED::'\n    const text = transfer.getData(TEXT)\n    let obj = {}\n\n    // If the existing plain text data is prefixed, it's Slate JSON data.\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length))\n      } catch (e) {\n        throw new Error(\n          'Failed to parse Slate data from `DataTransfer` object.'\n        )\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT] = text\n    }\n\n    obj[mime] = content\n    const string = `${prefix}${JSON.stringify(obj)}`\n    transfer.setData(TEXT, string)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default setEventTransfer\n","import Base64 from 'slate-base64-serializer'\nimport Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport { IS_IOS, IS_IE, IS_EDGE } from 'slate-dev-environment'\n\nimport cloneFragment from '../../utils/clone-fragment'\nimport getEventTransfer from '../../utils/get-event-transfer'\nimport setEventTransfer from '../../utils/set-event-transfer'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:after')\n\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin(options = {}) {\n  let isDraggingInternally = null\n  let isMouseDown = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const { value } = editor\n\n    // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n    const [targetRange] = event.getTargetRanges()\n    if (!targetRange) return next()\n\n    debug('onBeforeInput', { event })\n\n    event.preventDefault()\n\n    const { document, selection } = value\n    const range = editor.findRange(targetRange)\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward': {\n        editor.deleteAtRange(range)\n        break\n      }\n\n      case 'deleteWordBackward': {\n        editor.deleteWordBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteWordForward': {\n        editor.deleteWordForwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward': {\n        editor.deleteLineBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward': {\n        editor.deleteLineForwardAtRange(range)\n        break\n      }\n\n      case 'insertLineBreak':\n      case 'insertParagraph': {\n        const hasVoidParent = document.hasVoidParent(\n          selection.start.path,\n          editor\n        )\n\n        if (hasVoidParent) {\n          editor.moveToStartOfNextText()\n        } else {\n          editor.splitBlockAtRange(range)\n        }\n\n        break\n      }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText': {\n        // COMPAT: `data` should have the text for the `insertText` input type\n        // and `dataTransfer` should have the text for the\n        // `insertReplacementText` input type, but Safari uses `insertText` for\n        // spell check replacements and sets `data` to `null`. (2018/08/09)\n        const text =\n          event.data == null\n            ? event.dataTransfer.getData('text/plain')\n            : event.data\n\n        if (text == null) break\n\n        editor.insertTextAtRange(range, text, selection.marks)\n\n        // If the text was successfully inserted, and the selection had marks\n        // on it, unset the selection's marks.\n        if (selection.marks && value.document !== editor.value.document) {\n          editor.select({ marks: null })\n        }\n\n        break\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    debug('onBlur', { event })\n    editor.blur()\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next()\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    if (!path) return next()\n\n    debug('onClick', { event })\n\n    const node = document.getNode(path)\n    const ancestors = document.getAncestors(path)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node)\n    }\n\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    debug('onCopy', { event })\n    cloneFragment(event, editor)\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    debug('onCut', { event })\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    cloneFragment(event, editor, () => {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      const { value } = editor\n      const { document, selection } = value\n      const { end, isCollapsed } = selection\n      let voidPath\n\n      if (isCollapsed) {\n        for (const [node, path] of document.ancestors(end.path)) {\n          if (editor.isVoid(node)) {\n            voidPath = path\n            break\n          }\n        }\n      }\n\n      if (voidPath) {\n        editor.removeNodeByKey(voidPath)\n      } else {\n        editor.delete()\n      }\n    })\n\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    debug('onDragEnd', { event })\n    isDraggingInternally = null\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    debug('onDragStart', { event })\n\n    isDraggingInternally = true\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    const node = document.getNode(path)\n    const ancestors = document.getAncestors(path)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n    const selectionIncludesNode = value.blocks.some(block => block === node)\n\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node)\n    }\n\n    const fragment = editor.value.fragment\n    const encoded = Base64.serializeNode(fragment)\n    setEventTransfer(event, 'fragment', encoded)\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    const { value } = editor\n    const { document, selection } = value\n    const window = getWindow(event.target)\n    const target = editor.findEventRange(event)\n\n    if (!target) {\n      return next()\n    }\n\n    debug('onDrop', { event })\n\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    editor.focus()\n\n    // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n    const el = editor.findDOMNode(target.focus.path)\n\n    if (el) {\n      el.dispatchEvent(\n        new MouseEvent('mouseup', {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n        })\n      )\n    }\n\n    const draggedRange = selection\n\n    editor.select(target)\n\n    if (isDraggingInternally) {\n      editor.deleteAtRange(draggedRange)\n    }\n\n    if (type === 'text' || type === 'html') {\n      const { anchor } = target\n      let hasVoidParent = document.hasVoidParent(anchor.path, editor)\n\n      if (hasVoidParent) {\n        let p = anchor.path\n        let n = document.getNode(anchor.path)\n\n        while (hasVoidParent) {\n          const [nxt] = document.texts({ path: p })\n\n          if (!nxt) {\n            break\n          }\n\n          ;[n, p] = nxt\n          hasVoidParent = document.hasVoidParent(p, editor)\n        }\n\n        if (n) editor.moveToStartOfNode(n)\n      }\n\n      if (text) {\n        text.split('\\n').forEach((line, i) => {\n          if (i > 0) editor.splitBlock()\n          editor.insertText(line)\n        })\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    debug('onFocus', { event })\n\n    // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n    if (isMouseDown && !IS_IE && !IS_EDGE) {\n      editor.deselect().focus()\n    } else {\n      editor.focus()\n    }\n\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    debug('onInput')\n\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const selection = editor.findSelection(domSelection)\n\n    if (selection) {\n      editor.select(selection)\n    } else {\n      editor.blur()\n    }\n\n    // prettier-ignore\n    if (window.ENABLE_SLATE_LOGGING) console.log('    flush selAfterOnInput:', JSON.stringify(editor.value.selection.toJSON()))\n\n    const { anchorNode } = domSelection\n    editor.reconcileDOMNode(anchorNode)\n\n    // prettier-ignore\n    if (window.ENABLE_SLATE_LOGGING) console.log('    flush selAfterReconci:', JSON.stringify(editor.value.selection.toJSON()))\n    // prettier-ignore\n    if (window.ENABLE_SLATE_LOGGING) console.log(`    editor: len: ${editor.value.document.text.length} selSlate: ${editor.value.selection.anchor.offset} selNative: ${window.getSelection().anchorOffset} document: ${JSON.stringify(editor.value.document.toJSON())}`)\n\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', { event })\n\n    const { value } = editor\n    const { document, selection } = value\n    const { start } = selection\n\n    const selectedBlock = document.getClosestBlock(start.path)\n    const isRtl =\n      selectedBlock != null && selectedBlock.getTextDirection() === 'rtl'\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward()\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward()\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward()\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward()\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward()\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward()\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo()\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo()\n    }\n\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault()\n      return isRtl ? editor.moveToEndOfBlock() : editor.moveToStartOfBlock()\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault()\n      return isRtl ? editor.moveToStartOfBlock() : editor.moveToEndOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      return isRtl\n        ? editor.moveFocusToEndOfBlock()\n        : editor.moveFocusToStartOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      return isRtl\n        ? editor.moveFocusToStartOfBlock()\n        : editor.moveFocusToEndOfBlock()\n    }\n\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return isRtl ? editor.moveToEnd() : editor.moveToStart()\n      }\n\n      return isRtl ? editor.moveForward() : editor.moveBackward()\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return isRtl ? editor.moveToStart() : editor.moveToEnd()\n      }\n\n      return isRtl ? editor.moveBackward() : editor.moveForward()\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n      return isRtl ? editor.moveWordForward() : editor.moveWordBackward()\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n      return isRtl ? editor.moveWordBackward() : editor.moveWordForward()\n    }\n\n    if (\n      (!isRtl && Hotkeys.isExtendBackward(event)) ||\n      (isRtl && Hotkeys.isExtendForward(event))\n    ) {\n      event.preventDefault()\n      return editor.moveFocusBackward()\n    }\n\n    if (\n      (!isRtl && Hotkeys.isExtendForward(event)) ||\n      (isRtl && Hotkeys.isExtendBackward(event))\n    ) {\n      event.preventDefault()\n      return editor.moveFocusForward()\n    }\n\n    next()\n  }\n\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseDown(event, editor, next) {\n    debug('onMouseDown', { event })\n    isMouseDown = true\n    next()\n  }\n\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseUp(event, editor, next) {\n    debug('onMouseUp', { event })\n    isMouseDown = false\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    debug('onPaste', { event })\n\n    const { value } = editor\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next()\n      const { document, selection, startBlock } = value\n      if (editor.isVoid(startBlock)) return next()\n\n      const defaultBlock = startBlock\n      const defaultMarks = document.getInsertMarksAtRange(selection)\n      const frag = Plain.deserialize(text, { defaultBlock, defaultMarks })\n        .document\n      editor.insertFragment(frag)\n    }\n\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', { event })\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const selection = editor.findSelection(domSelection)\n    // prettier-ignore\n    if (window.ENABLE_SLATE_LOGGING && domSelection && editor.value.selection.anchor && selection && selection.anchor) console.log(`!! onSelect domOffset:${domSelection.anchorOffset} oldSlate: ${editor.value.selection.anchor.offset} newSlate: ${selection.anchor.offset}`)\n\n    if (selection) {\n      editor.select(selection)\n    } else {\n      editor.blur()\n    }\n\n    // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n    isMouseDown = false\n\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onMouseDown,\n    onMouseUp,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AfterPlugin\n","import { Node } from 'slate'\n\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key, win = window) {\n  // warning(\n  //   false,\n  //   'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.'\n  // )\n\n  if (Node.isNode(key)) {\n    key = key.key\n  }\n\n  const el = win.document.querySelector(`[${DATA_ATTRS.KEY}=\"${key}\"]`)\n\n  if (!el) {\n    throw new Error(\n      `Unable to find a DOM node for \"${key}\". This is often because of forgetting to add \\`props.attributes\\` to a custom component.`\n    )\n  }\n\n  return el\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMNode\n","import Debug from 'debug'\nimport { Range } from 'slate'\nimport Hotkeys from 'slate-hotkeys'\nimport getWindow from 'get-window'\nimport {\n  IS_FIREFOX,\n  IS_IE,\n  IS_IOS,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport DATA_ATTRS from '../../constants/data-attributes'\nimport SELECTORS from '../../constants/selectors'\nimport sanitizeDomOnError from '../../utils/sanitize-dom-on-error'\nimport safelyGetParentKeyNode from '../../utils/safely-get-parent-key-node'\nimport findDomNode from '../../utils/find-dom-node'\nimport { reconcileDOMNode } from '../../plugins/react/commands'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:before')\n\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  let activeElement = null\n  let isComposing = false\n  let isCopying = false\n  let isDragging = false\n  let isUserActionPerformed = false\n\n  let nextNativeOperation = null\n  let currentlySelectedCompositionNode = null\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`!! onBeforeInput with data:${JSON.stringify(event.data)} inputType:${event.inputType} has2:${HAS_INPUT_EVENTS_LEVEL_2} isSynthetic:${!!event.nativeEvent}`)\n\n    // If the user has started a composition for something like a chinese character\n    // then wait to modify slate's AST and wait to force a react render until the composition is done.\n    if (checkIsComposing()) return\n\n    const isSynthetic = !!event.nativeEvent\n    if (editor.readOnly) return\n    isUserActionPerformed = true\n\n    // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return\n\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n    // Single character inserts can be handled natively. Allows native rendering\n    // which preserves the native browser spell check handling.\n    if (isSynthetic) {\n      const isCollapsed = editor.value.selection.isCollapsed\n\n      if (!isCollapsed) {\n        editor.delete()\n      }\n\n      const inputText = (event.data || '')\n        .replace(/\\n\\r/g, '\\n')\n        .replace(/\\r/g, '\\n')\n      const hasNewLines = inputText.indexOf('\\n') >= 0\n\n      if (isCollapsed && !hasNewLines) {\n        saveCurrentNativeNode(editor)\n      } else {\n        event.preventDefault()\n\n        if (!hasNewLines) {\n          editor.insertText(event.data, null, false)\n        } else {\n          const chunks = inputText.split('\\n')\n\n          chunks.map((text, i) => {\n            if (text.length !== 0) {\n              /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    insert: |${JSON.stringify(text)}|`)\n              editor.insertText(text, null, false)\n            }\n\n            if (i !== chunks.length - 1) {\n              /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log('    inserting line break')\n              editor.splitBlock()\n            }\n          })\n        }\n      }\n    } else {\n      debug('onBeforeInput', { event })\n      next()\n    }\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const { relatedTarget, target } = event\n    const window = getWindow(target)\n\n    // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n    if (activeElement === window.document.activeElement) return\n\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n    if (relatedTarget) {\n      const el = editor.findDOMNode([])\n\n      // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n      if (relatedTarget === el) return\n\n      // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n      if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return\n\n      // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n      const node = editor.findNode(relatedTarget)\n\n      if (\n        el != null &&\n        el.contains(relatedTarget) &&\n        node &&\n        !editor.isVoid(node)\n      ) {\n        return\n      }\n    }\n\n    debug('onBlur', { event })\n    next()\n  }\n\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`!! onCompositionEnd isComposing:${isComposing}`)\n\n    isUserActionPerformed = true\n    isComposing = false\n\n    // Since we may have skipped some input events during the composition, once it is over\n    // we need to manually call flush to sync the dom to the slate AST\n    saveCurrentlySelectedCompositionNode()\n    saveCurrentNativeNode(editor)\n    syncDomToSlateAst(editor)\n\n    debug('onCompositionEnd', { event })\n    next()\n  }\n\n  function onCompositionUpdate() {\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`!! onCompositionUpdate isComposing:${isComposing}`)\n    isComposing = true\n    saveCurrentlySelectedCompositionNode()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    debug('onClick', { event })\n    isUserActionPerformed = true\n    next()\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`!! onCompositionStart isComposing:${isComposing} isCollapsed:${editor.value.selection.isCollapsed}`)\n\n    isComposing = true\n\n    const { value } = editor\n    const { selection } = value\n    isUserActionPerformed = true\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete()\n    }\n\n    saveCurrentlySelectedCompositionNode()\n    saveCurrentNativeNode(editor)\n\n    debug('onCompositionStart', { event })\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCopy', { event })\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return\n\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCut', { event })\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false\n    debug('onDragEnd', { event })\n    next()\n  }\n\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnter(event, editor, next) {\n    debug('onDragEnter', { event })\n    next()\n  }\n\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragExit(event, editor, next) {\n    debug('onDragExit', { event })\n    next()\n  }\n\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragLeave(event, editor, next) {\n    debug('onDragLeave', { event })\n    next()\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    const node = editor.findNode(event.target)\n\n    if (!node || editor.isVoid(node)) {\n      event.preventDefault()\n    }\n\n    // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n    if (IS_IE) {\n      event.preventDefault()\n    }\n\n    // If a drag is already in progress, don't do this again.\n    if (!isDragging) {\n      isDragging = true\n\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move'\n      }\n    }\n\n    debug('onDragOver', { event })\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    isDragging = true\n    debug('onDragStart', { event })\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return\n    isUserActionPerformed = true\n\n    // Prevent default so the DOM's value isn't corrupted.\n    event.preventDefault()\n\n    debug('onDrop', { event })\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const el = editor.findDOMNode([])\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (IS_FIREFOX && event.target !== el) {\n      el.focus()\n      return\n    }\n\n    debug('onFocus', { event })\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`!! onInput isComposing:${isComposing} hasOp:${!!nextNativeOperation}`)\n\n    if (checkIsComposing()) {\n      // Safari is broken :(\n      if (HAS_INPUT_EVENTS_LEVEL_2) return\n\n      // During compositions we _have_ to scan the dom to see what has changed, we cannot ever rely on onBeforeInput\n      // modifying the AST since that will change the dom text node!\n      saveCurrentNativeNode(editor)\n      syncDomToSlateAst(editor)\n      return\n    }\n\n    // The input event fires after the browser has modified the dom\n    // At this point we can read the dom to see what the browser did and import that change into slate's AST\n    if (syncDomToSlateAst(editor)) {\n      return\n    }\n\n    if (editor.value.selection.isBlurred) return\n    isUserActionPerformed = true\n    debug('onInput', { event })\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`!! onKeyDown isComposing:${isComposing} hasOp:${!!nextNativeOperation} mods:${event.ctrlKey ? 'ctrl-' : ''}${event.altKey ? 'alt-' : ''}${event.shiftKey ? 'shift-' : ''}${event.metaKey ? 'meta-' : ''} key:${event.key} which:${event.which}`)\n\n    // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n    if (checkIsComposing()) {\n      if (Hotkeys.isCompose(event)) event.preventDefault()\n      return\n    }\n\n    // Optimization: Bail out if none of the keys we care about were pressed!\n    if (\n      !event.ctrlKey &&\n      !event.altKey &&\n      !event.shiftKey &&\n      !event.metaKey &&\n      event.key != null\n    ) {\n      switch (event.key.toLowerCase()) {\n        case 'arrowdown':\n        case 'arrowleft':\n        case 'arrowright':\n        case 'arrowup':\n        case 'pageup':\n        case 'pagedown':\n        case 'backspace':\n        case 'delete':\n        case 'insert':\n        case 'home':\n        case 'end':\n        case 'enter':\n        case 'tab':\n        case 'space':\n          break\n\n        default:\n          return\n      }\n    }\n\n    // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n    if (\n      !IS_IOS &&\n      (Hotkeys.isBold(event) ||\n        Hotkeys.isDeleteBackward(event) ||\n        Hotkeys.isDeleteForward(event) ||\n        Hotkeys.isDeleteLineBackward(event) ||\n        Hotkeys.isDeleteLineForward(event) ||\n        Hotkeys.isDeleteWordBackward(event) ||\n        Hotkeys.isDeleteWordForward(event) ||\n        Hotkeys.isItalic(event) ||\n        Hotkeys.isRedo(event) ||\n        // Hotkeys.isSplitBlock(event) ||\n        Hotkeys.isTransposeCharacter(event) ||\n        Hotkeys.isUndo(event))\n    ) {\n      event.preventDefault()\n    }\n\n    isUserActionPerformed = true\n    debug('onKeyDown', { event })\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return\n    isUserActionPerformed = true\n\n    // Prevent defaults so the DOM state isn't corrupted.\n    event.preventDefault()\n\n    debug('onPaste', { event })\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n    if (checkIsComposing() && HAS_INPUT_EVENTS_LEVEL_2) return\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n    isUserActionPerformed = true\n\n    debug('onSelect', { event })\n    next()\n  }\n\n  function userActionPerformed() {\n    return isUserActionPerformed\n  }\n\n  function clearUserActionPerformed() {\n    isUserActionPerformed = false\n    return null\n  }\n\n  /**\n   * The job of this function is to look at the dom, see what text is there, and sync that text into slate.\n   * We use this for things like asian language compositions, auto suggest/correct, and mac's accented character input.\n   * Each of these are too complicated to replicate perfectly with the events the browser exposes to us.  Additionally,\n   * the browser relies on us not modifying the text node.  If we touch the text node's content in any way, then the\n   * browser will abort any composition that it has in progress!  So our goal is to let the browser do its things,\n   * avoid touching it or syncing its state at all, and then once it is done, we will sync its state into slate,\n   * which is what this function does.\n   *\n   * A slate AST will look something like this:\n   * document: {\n   *   nodes: [{\n   *     type: 'line',\n   *     nodes: [{key: '42', type: 'text', text: '**foo**'}],\n   *   ]}\n   * }\n   *\n   * The corresponding dom structure will look something like:\n   * <span data-key=42>\n   *   <span decoration=\"syntax\">\n   *     <span data-string=true>**</span>\n   *   </span>\n   *   <span decoration=\"bold\">\n   *     <span data-string=true>foo</span>\n   *   </span>\n   *   <span decoration=\"syntax\">\n   *     <span data-string=true>**</span>\n   *   </span>\n   * </span>\n   *\n   * The important thing to note about the above is that there is a single span tag that corresponds to each Text node\n   * in the AST.  Generally speaking, thatSpanNode.textContent === LeaftAstTextNode.text\n   *\n   * The part where that is not true is zero-width spaces.  Slate needs to force text nodes to be created, and it does\n   * this by creating dom nodes that just have a zero width space in them.  The problem with this is the browser doesn't\n   * know that we don't want them.  So when a user types \"a\" to start, they will only see one character, but in the dom\n   * there are actually two (because the browser didn't remove the zero-width space).  So, we have to do some surgery\n   * on the dom to clean these up and keep them out of the slate AST.\n   */\n\n  function syncDomToSlateAst(editor) {\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log('!! syncDomToSlateAst')\n\n    const nodesToIncorporate = nextNativeOperation || []\n    nextNativeOperation = null\n\n    addCurrentlySelectedKeyNode(editor, nodesToIncorporate)\n    if (nodesToIncorporate.length === 0) return false\n\n    const {\n      anchorNode: textNode,\n      anchorOffset: currentOffset,\n    } = window.getSelection()\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    textNode: ${textNode.textContent} ${textNode.textContent.length}`)\n\n    // Just in case: Make sure the currently selected node is in the list of nodes we are going to sync\n\n    // Now sync the content of all nodes in the lis tinto our AST\n    let failed = false\n\n    for (const node of nodesToIncorporate) {\n      if (\n        sanitizeDomOnError(editor, node, () => syncNodeToSlateAst(editor, node))\n          .failed\n      ) {\n        failed = true\n      }\n    }\n\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log('    flush selAfterInsert :',JSON.stringify(editor.value.selection.toJSON()))\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    editor: len: ${editor.value.document.text.length} selSlate: ${editor.value.selection.anchor.offset} selNative: ${currentOffset} document: ${JSON.stringify(editor.value.document.toJSON())}`)\n\n    // If any of the syncing above failed, then we can't really do much else here, let's just bail out to avoid\n    // cascading errors.\n    if (failed) return\n\n    // Finally make sure the browser and slate agree on where your selection should be\n    sanitizeDomOnError(editor, textNode, () =>\n      syncSelection(editor, textNode, currentOffset)\n    )\n\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log('    flush selAfterSelect2:',JSON.stringify(editor.value.selection.toJSON()))\n\n    // Last step is more of a sanity thing: Make sure the dom structure and text roughly match what slate things they should!\n    // This is normally called in the after plugin, however if we do that there, it will re-sync the selection, which we\n    // just did above, which wastes about a millisecond.\n    reconcileDOMNode(editor, textNode)\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log('    flush selAfterReconci:',JSON.stringify(editor.value.selection.toJSON()))\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    editor: len: ${editor.value.document.text.length} selSlate: ${editor.value.selection.anchor.offset} selNative: ${window.getSelection().anchorOffset} document: ${JSON.stringify(editor.value.document.toJSON())}`)\n\n    return true\n  }\n\n  function syncNodeToSlateAst(editor, slateDomSpan) {\n    // Re-read the slate span from the dom, _just in case_ it has been removed from the dom since!\n    const key = slateDomSpan.getAttribute(DATA_ATTRS.KEY)\n    slateDomSpan = findDomNode(key)\n\n    const path = editor.value.document.getPath(key)\n    const slateAstNode = editor.value.document.getNode(key)\n\n    // Strip any zero-width spaces that slate uses internally.  React will clean these up too, but we are trying to\n    // avoid having to react-render right now\n    sanitizeZeroWidthSpaces(editor, slateDomSpan)\n\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    slateDomSpan: ${slateDomSpan.textContent} ${slateDomSpan.textContent.length}`)\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    slateAstNode: ${slateAstNode.text} ${slateAstNode.text.length}`)\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log('    flush selBeforeInsert:',JSON.stringify(editor.value.selection.toJSON()))\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    editor: len: ${editor.value.document.text.length} selSlate: ${editor.value.selection.anchor.offset} selNative: ${window.getSelection().anchorOffset} document: ${JSON.stringify(editor.value.document.toJSON())}`)\n\n    // Now grab the full current text content of the slate dom node that represents the full slate AST node\n    // We do need to strip any zero-width spaces though, since slate uses them for decorations and other things,\n    // so they might legitimately need to be in the dom, but should never be in the AST\n    const newTextContent = slateDomSpan.textContent.replace(/[\\uFEFF\\b]/g, '')\n    syncTextToAst(editor, slateAstNode, path, newTextContent)\n  }\n\n  function syncSelection(editor, textNode, currentOffset) {\n    // Now we need to go and update the selection.  First, we modify slate's internal representation of the selection:\n    const newSelectionPosition = Math.min(\n      textNode.textContent.length,\n      currentOffset\n    )\n    // This maps a dom position to a slate position.  Remember above: A single slate node will have lots of child\n    // dom nodes, which means the dom offset is usually going to be much different from what the offset is in the slate\n    // AST\n    const point = editor.findPoint(textNode, newSelectionPosition)\n    if (point == null)\n      throw Error('Unable to translate dom position to slate position!')\n    setSlateSelection(editor, point.path, point.key, point.offset)\n    /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log('    flush selAfterSelect1:',JSON.stringify(editor.value.selection.toJSON()))\n\n    // There's a good chance that slate will do nothing with the update above, partly because we have disabled selection\n    // updates in some cases.  So, let's also force the browser to move the selection to where we want.\n    // (IIRC in some cases slate was also moving the selection back to an old place sometimes, so this fixes that too).\n    setDomSelection(textNode, newSelectionPosition)\n  }\n\n  /**\n   * Intelligently syncs text changes to the slate AST.  If we can determine with confidence that all the user did\n   * was insert a single letter or two, then there's a much faster code path we can take.  If we can't determine that,\n   * then we'll replace the entire text content of the AST node, _but_ it will take an extra 2-3 ms\n   */\n\n  function syncTextToAst(editor, slateAstNode, path, newText) {\n    const oldText = slateAstNode.text\n    if (newText === oldText) return\n\n    const key = slateAstNode.key\n\n    // Look for the number of characters at the start and end of the two pieces of text that exactly match,\n    // position for position.\n    const numStartingCharsSame = commonCharactersAtStart(newText, oldText)\n    const numEndingCharsSame = commonCharactersAtEnd(\n      newText.substring(numStartingCharsSame),\n      oldText.substring(numStartingCharsSame)\n    )\n\n    // Now, if the number of matching characters is the same as the length of the old text, then we know the new\n    // text _only_ contains additions, and those additions start where the matching characters at the start stopped.\n    if (numStartingCharsSame + numEndingCharsSame !== oldText.length) {\n      // There is a deletion somewhere, so let's just replace the whole node's text\n      editor.insertTextAtRange(\n        Range.create({\n          anchor: { path, key, offset: 0 },\n          focus: { path, key, offset: slateAstNode.text.length },\n        }),\n        newText\n      )\n    } else {\n      // We are _just_ inserting characters, so we can do a much faster AST operation!\n      const insertions = newText.substring(\n        numStartingCharsSame,\n        newText.length - numEndingCharsSame\n      )\n\n      editor.controller.fastInsertText(\n        path,\n        numStartingCharsSame,\n        insertions,\n        null\n      )\n    }\n  }\n\n  /** Returns the number of continous characters that exactly match, starting at the beginning of the string */\n\n  function commonCharactersAtStart(left, right) {\n    for (let i = 0; i < left.length && i < right.length; i++) {\n      if (left[i] !== right[i]) return i\n    }\n    return Math.min(left.length, right.length)\n  }\n\n  /** Returns the number of continous characters that exactly match, starting at the end of the string */\n\n  function commonCharactersAtEnd(left, right) {\n    const leftLength = left.length\n    const rightLength = right.length\n\n    for (let i = 0; i < leftLength && i < rightLength; i++) {\n      if (left[leftLength - i - 1] !== right[rightLength - i - 1]) return i\n    }\n    return Math.min(leftLength, rightLength)\n  }\n\n  /** Syncs a new selection position to slate, but only if slate does not already have that position as its value */\n\n  function setSlateSelection(editor, path, key, offset) {\n    const { selection } = editor.value\n\n    if (\n      !selection.isCollapsed ||\n      selection.anchor.key !== key ||\n      selection.anchor.offset !== offset\n    ) {\n      const point = { path, key, offset }\n      editor.select(Range.create({ anchor: point, focus: point }))\n    }\n  }\n\n  /** Syncs a new selection position to the dom, but only if the dom does not already have that position */\n\n  function setDomSelection(textNode, offset) {\n    const selection = window.getSelection()\n\n    if (\n      selection == null ||\n      selection.anchorNode !== textNode ||\n      selection.focusNode !== textNode ||\n      selection.anchorOffset !== offset ||\n      selection.focusOffset !== offset\n    ) {\n      selection.collapse(textNode, offset)\n    }\n  }\n\n  /**\n   * Slate has two dom representations for leaf nodes:\n   * <span data-string=true>abc</span>\n   * <span data-zero-width=true></span>\n   * When a node is first created, it starts as the zero-width dom node.  When we let the browser modify it, we will\n   * be left with the zero-width markup, but it now contains more than just a zero-width string.  So, in this case,\n   * we want to strip those attributes.\n   * Additionally, if a node contains anything more than just a zero width string, then we should remove any zero-width\n   * spaces from it if has any.\n   */\n\n  function sanitizeZeroWidthSpaces(editor, slateDomSpan) {\n    const allChildTextNodes = slateDomSpan.querySelectorAll(\n      `${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`\n    )\n\n    for (const stringNode of allChildTextNodes) {\n      const isStringNode = stringNode.hasAttribute(DATA_ATTRS.STRING)\n      const isZeroWidth = stringNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n\n      // This should basically always be true:\n      if (isStringNode || isZeroWidth) {\n        const hasZeroWidthChars = stringNode.textContent.indexOf('\\uFEFF') >= 0\n\n        // A string node with any zero width characters needs to be cleaned\n        // A zero width node with only a zero width character is ok though:\n        if (\n          (isStringNode && hasZeroWidthChars) ||\n          (isZeroWidth && stringNode.textContent !== '\\uFEFF')\n        ) {\n          /* prettier-ignore */ if (window.ENABLE_SLATE_LOGGING) console.log(`    REPLACING ${stringNode.childNodes.length}`)\n\n          // If there's only a single text node here, then we modify it's dom content directly\n          // If there are multiple though, then it's a bit of an unknown situation, so we replace the entire span\n          removeZeroWidths(stringNode)\n\n          stringNode.removeAttribute(DATA_ATTRS.ZERO_WIDTH)\n          stringNode.removeAttribute(DATA_ATTRS.LENGTH)\n        }\n      }\n    }\n  }\n\n  function removeZeroWidths(parent) {\n    eachTextNode(parent, textNode => {\n      while (true) {\n        const pos = textNode.textContent.indexOf('\\uFEFF')\n        if (pos === -1) break\n        textNode.deleteData(pos, 1)\n      }\n    })\n  }\n\n  function eachTextNode(node, cb) {\n    for (const child of node.childNodes) {\n      if (child.nodeType === 1) {\n        eachTextNode(child, cb)\n      } else if (child.nodeType === 3) {\n        cb(child)\n      }\n    }\n  }\n\n  function saveCurrentNativeNode(editor) {\n    if (!nextNativeOperation) {\n      nextNativeOperation = []\n    }\n\n    addCurrentlySelectedKeyNode(editor, nextNativeOperation)\n  }\n\n  function saveCurrentlySelectedCompositionNode() {\n    const selection = window.getSelection()\n\n    currentlySelectedCompositionNode =\n      selection == null ? null : selection.anchorNode\n  }\n\n  function checkIsComposing() {\n    // If React has come through and re-rendered the dom, then it may have interrupted a composition, and there\n    // may not have been an onCompositionEnd event.  So if the node that was last selected during the composition\n    // no longer exists in the dom, let's assume the user aborted the composition.\n    if (isComposing) {\n      if (currentlySelectedCompositionNode == null) isComposing = false\n\n      if (!window.document.body.contains(currentlySelectedCompositionNode)) {\n        console.warn(\n          'Aborting composition because previously selection node is no longer in the dom!'\n        )\n\n        isComposing = false\n      }\n    }\n\n    return isComposing\n  }\n\n  function addCurrentlySelectedKeyNode(editor, keyNodes) {\n    // The node with a data-key property entirely encompasses a single slate AST text node.\n    // It'll have lots of children for the various decorations, but its entire textContent should map\n    // to a single AST node\n    const currentSpan = safelyGetParentKeyNode(window.getSelection().anchorNode)\n\n    // Save a reference to the currently selected AST node\n    // Once the browser has modified the dom, we'll use these to figure out what changes were made\n    if (keyNodes.indexOf(currentSpan) === -1) {\n      keyNodes.push(currentSpan)\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCompositionEnd,\n    onCompositionUpdate,\n    onCompositionStart,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragEnter,\n    onDragExit,\n    onDragLeave,\n    onDragOver,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onPaste,\n    onSelect,\n    queries: {\n      userActionPerformed,\n      isComposing: checkIsComposing,\n    },\n    commands: {\n      clearUserActionPerformed,\n    },\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default BeforePlugin\n","import { IS_ANDROID } from 'slate-dev-environment'\n\nimport AndroidPlugin from '../android'\nimport NoopPlugin from '../debug/noop'\n\nimport AfterPlugin from './after'\nimport BeforePlugin from './before'\n\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction DOMPlugin(options = {}) {\n  const { plugins = [] } = options\n  const beforePlugin = BeforePlugin()\n  const afterPlugin = AfterPlugin()\n\n  // COMPAT: Add Android specific handling separately before it gets to the\n  // other plugins because it is specific (other browser don't need it) and\n  // finicky (it has to come before other plugins to work).\n  const androidPlugins = IS_ANDROID\n    ? [AndroidPlugin(options), NoopPlugin(options)]\n    : []\n\n  return [...androidPlugins, beforePlugin, ...plugins, afterPlugin]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DOMPlugin\n","function RestoreDOMPlugin() {\n  /**\n   * Makes sure that on the next Content `render` the DOM is restored.\n   * This gets us around issues where the DOM is in a different state than\n   * React's virtual DOM and would crash.\n   *\n   * @param {Editor} editor\n   */\n\n  function restoreDOM(editor) {\n    const tmp = editor.tmp.contentRef.current.tmp\n    tmp.contentKey = tmp.contentKey + 1\n  }\n\n  return {\n    commands: {\n      restoreDOM,\n    },\n  }\n}\n\nexport default RestoreDOMPlugin\n","/**\n * Takes a React Synthetic Event or a DOM Event and turns it into a String that\n * is easy to log. It's succinct and keeps info to a bare minimum.\n *\n * @param {Event} event\n */\n\nexport default function stringifyEvent(event) {\n  const e = event.nativeEvent || event\n\n  switch (e.type) {\n    case 'keydown':\n      return `${e.type} ${JSON.stringify(e.key)}`\n    case 'input':\n    case 'beforeinput':\n    case 'textInput':\n      return `${e.type}:${e.inputType} ${JSON.stringify(e.data)}`\n    default:\n      return e.type\n  }\n}\n","import Debug from 'debug'\nimport EVENT_HANDLERS from '../../constants/event-handlers'\nimport stringifyEvent from './stringify-event'\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:events')\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugEventsPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {\n      const s = stringifyEvent(event)\n      debug(s)\n      next()\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DebugEventsPlugin\n","import Debug from 'debug'\nimport EVENT_HANDLERS from '../../constants/event-handlers'\nimport stringifyEvent from './stringify-event'\n\n/**\n * Constants\n */\n\nconst INTERVAL = 2000\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:batch-events')\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugBatchEventsPlugin() {\n  /**\n   * When the batch started\n   *\n   * @type {Date}\n   */\n\n  let startDate = null\n\n  /**\n   * The timeoutId used to cancel the timeout\n   *\n   * @type {Any}\n   */\n\n  let timeoutId = null\n\n  /**\n   * An array of events not yet dumped with `debug`\n   *\n   * @type {Array}\n   */\n\n  const events = []\n\n  /**\n   * Send all events to debug\n   *\n   * Note: Formatted so it can easily be cut and pasted as text for analysis or\n   * documentation.\n   */\n\n  function dumpEvents() {\n    debug(`\\n${events.join('\\n')}`)\n    events.length = 0\n  }\n\n  /**\n   * Push an event on to the Array of events for debugging in a batch\n   *\n   * @param {Event} event\n   */\n\n  function pushEvent(event) {\n    if (events.length === 0) {\n      startDate = new Date()\n    }\n\n    const s = stringifyEvent(event)\n    const now = new Date()\n    events.push(`- ${now - startDate} - ${s}`)\n    clearTimeout(timeoutId)\n    timeoutId = setTimeout(dumpEvents, INTERVAL)\n  }\n\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {\n      pushEvent(event)\n      next()\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DebugBatchEventsPlugin\n","import Debug from 'debug'\n\n/**\n * Debug mutations function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:mutations')\n\n/**\n * Properties on a MutationRecord\n *\n * @type {Object}\n */\n\nconst MUTATION_PROPERTIES = [\n  'type',\n  'oldValue',\n  'target',\n  'addedNodes',\n  'removedNodes',\n  'attributeName',\n  'attributeNamespace',\n  'nextSibling',\n  'previousSibling',\n]\n\n/**\n * Takes a DOM node and returns an easily readable version of it.\n *\n * @param {DOMNode} node\n */\n\nfunction normalizeNode(node) {\n  if (node.nodeType === window.Node.TEXT_NODE) {\n    return node.textContent\n  } else if (node.nodeType === window.Node.ELEMENT_NODE) {\n    const { outerHTML, innerHTML } = node\n    if (outerHTML == null) return JSON.stringify(node.textContent)\n    return outerHTML.slice(0, outerHTML.indexOf(innerHTML))\n  } else {\n    return `Node(type=${node.nodeType}`\n  }\n}\n\n/**\n * A plugin that sends short easy to digest debug info about each dom mutation\n * to browser.\n *\n * More information about mutations here:\n *\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver>\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord>\n *\n * @param {Object} options\n */\n\nfunction DebugMutationsPlugin() {\n  const observer = new window.MutationObserver(mutations => {\n    const array = Array.from(mutations).map(mutationRecord => {\n      const object = {}\n\n      // Only add properties that provide meaningful values to the object\n      // to make the debug info easier to read\n      MUTATION_PROPERTIES.forEach(key => {\n        let value = mutationRecord[key]\n        if (value == null) return\n\n        // Make NodeList easier to read\n        if (value instanceof window.NodeList) {\n          if (value.length === 0) return\n\n          object[key] = Array.from(value)\n            .map(normalizeNode)\n            .join(', ')\n          return\n        }\n\n        // Make Node easier to read\n        if (value instanceof window.Node) {\n          value = normalizeNode(value)\n        }\n\n        object[key] = value\n      })\n\n      return object\n    })\n\n    // The first argument must not be the array as `debug` renders the first\n    // argument in a different way than the rest\n    debug(`${array.length} Mutations`, ...array)\n  })\n\n  /**\n   * The previously observed DOM node\n   *\n   * @type {DOMNode}\n   */\n\n  let prevRootEl = null\n\n  /**\n   * Start observing the DOM node for mutations if it isn't being observed\n   */\n\n  function start(event, editor, next) {\n    const rootEl = editor.findDOMNode([])\n\n    if (rootEl === prevRootEl) return next()\n\n    debug('start')\n\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true,\n    })\n\n    prevRootEl = rootEl\n\n    next()\n  }\n\n  /**\n   * Stop observing the DOM node for mutations\n   */\n\n  function stop(event, editor, next) {\n    debug('stop')\n\n    observer.disconnect()\n    prevRootEl = null\n    next()\n  }\n\n  return {\n    onComponentDidMount: start,\n    onComponentDidUpdate: start,\n    onComponentWillUnmount: stop,\n  }\n}\n\nexport default DebugMutationsPlugin\n","import Debug from 'debug'\n\nimport { IS_ANDROID } from 'slate-dev-environment'\nimport PlaceholderPlugin from 'slate-react-placeholder'\nimport EditorPropsPlugin from './editor-props'\nimport RenderingPlugin from './rendering'\nimport CommandsPlugin from './commands'\nimport QueriesPlugin from './queries'\nimport DOMPlugin from '../dom'\nimport RestoreDOMPlugin from './restore-dom'\nimport DebugEventsPlugin from '../debug/debug-events'\nimport DebugBatchEventsPlugin from '../debug/debug-batch-events'\nimport DebugMutationsPlugin from '../debug/debug-mutations'\n\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction ReactPlugin(options = {}) {\n  const { placeholder = '' } = options\n  const debugEventsPlugin = Debug.enabled('slate:events')\n    ? DebugEventsPlugin(options)\n    : null\n  const debugBatchEventsPlugin = Debug.enabled('slate:batch-events')\n    ? DebugBatchEventsPlugin(options)\n    : null\n  const debugMutationsPlugin = Debug.enabled('slate:mutations')\n    ? DebugMutationsPlugin(options)\n    : null\n  const renderingPlugin = RenderingPlugin(options)\n  const commandsPlugin = CommandsPlugin(options)\n  const queriesPlugin = QueriesPlugin(options)\n  const editorPropsPlugin = EditorPropsPlugin(options)\n  const domPlugin = DOMPlugin(options)\n  const restoreDomPlugin = RestoreDOMPlugin()\n\n  // Disable placeholder for Android because it messes with reconciliation\n  // and doesn't disappear until composition is complete.\n  // e.g. In empty, type \"h\" and autocomplete on Android 9 and deletes all text.\n  const placeholderPlugin =\n    IS_ANDROID || placeholder === null\n      ? null\n      : PlaceholderPlugin({\n          placeholder,\n          when: (editor, node) =>\n            node.object === 'document' &&\n            node.text === '' &&\n            node.nodes.size === 1 &&\n            Array.from(node.texts()).length === 1,\n        })\n\n  return [\n    debugEventsPlugin,\n    debugBatchEventsPlugin,\n    debugMutationsPlugin,\n    editorPropsPlugin,\n    domPlugin,\n    restoreDomPlugin,\n    placeholderPlugin,\n    renderingPlugin,\n    commandsPlugin,\n    queriesPlugin,\n  ]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default ReactPlugin\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport invariant from 'tiny-invariant'\nimport memoizeOne from 'memoize-one'\nimport warning from 'tiny-warning'\nimport omit from 'lodash/omit'\nimport { Editor as Controller } from 'slate'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport OTHER_HANDLERS from '../constants/other-handlers'\nimport Content from './content'\nimport ReactPlugin from '../plugins/react'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nclass Editor extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static __propTypes = {\n    autoCorrect: Types.bool,\n    autoFocus: Types.bool,\n    className: Types.string,\n    defaultValue: SlateTypes.value,\n    id: Types.string,\n    onChange: Types.func,\n    onContextMenu: Types.func,\n    options: Types.object,\n    placeholder: Types.any,\n    plugins: Types.array,\n    readOnly: Types.bool,\n    role: Types.string,\n    schema: Types.object,\n    spellCheck: Types.bool,\n    style: Types.object,\n    tabIndex: Types.number,\n    value: SlateTypes.value,\n    ...EVENT_HANDLERS.reduce((obj, handler) => {\n      obj[handler] = Types.func\n      return obj\n    }, {}),\n    ...OTHER_HANDLERS.reduce((obj, handler) => {\n      obj[handler] = Types.func\n      return obj\n    }, {}),\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    autoFocus: false,\n    autoCorrect: true,\n    onChange: () => {},\n    options: {},\n    placeholder: '',\n    plugins: [],\n    readOnly: false,\n    schema: {},\n    spellCheck: true,\n  }\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n  state = { value: this.props.defaultValue, contentKey: 0 }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    mounted: false,\n    change: null,\n    resolves: 0,\n    updates: 0,\n    contentRef: React.createRef(),\n  }\n\n  /**\n   * When the component first mounts, flush a queued change if one exists.\n   */\n\n  componentDidMount() {\n    this.tmp.mounted = true\n    this.tmp.updates++\n\n    if (this.props.autoFocus) {\n      this.focus()\n    }\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component updates, flush a queued change if one exists.\n   */\n\n  componentDidUpdate() {\n    this.tmp.updates++\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component unmounts, make sure async commands don't trigger react updates.\n   */\n\n  componentWillUnmount() {\n    this.tmp.mounted = false\n  }\n\n  /**\n   * Render the editor.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    debug('render', this)\n\n    // Re-resolve the controller if needed based on memoized props.\n    const { commands, placeholder, plugins, queries, schema } = this.props\n\n    this.resolveController(\n      plugins,\n      schema,\n      commands,\n      queries,\n      placeholder,\n      ReactPlugin\n    )\n\n    // Set the current props on the controller.\n    const { options, readOnly, value: valueFromProps } = this.props\n    const { value: valueFromState } = this.state\n    const value = valueFromProps || valueFromState\n    const { contentKey } = this.state\n    this.controller.setReadOnly(readOnly)\n    this.controller.setValue(value, options)\n\n    const {\n      autoCorrect,\n      className,\n      id,\n      role,\n      spellCheck,\n      tabIndex,\n      style,\n      tagName,\n      onContextMenu,\n    } = this.props\n\n    const domProps = omit(this.props, Object.keys(Editor.__propTypes))\n\n    const children = (\n      <Content\n        {...domProps}\n        ref={this.tmp.contentRef}\n        autoCorrect={autoCorrect}\n        className={className}\n        contentKey={contentKey}\n        editor={this}\n        id={id}\n        onContextMenu={onContextMenu}\n        onEvent={(handler, event) => this.run(handler, event)}\n        readOnly={readOnly}\n        role={role}\n        spellCheck={spellCheck}\n        style={style}\n        tabIndex={tabIndex}\n        tagName={tagName}\n      />\n    )\n\n    // Render the editor's children with the controller.\n    const element = this.controller.run('renderEditor', {\n      ...this.props,\n      editor: this,\n      children,\n    })\n\n    return element\n  }\n\n  /**\n   * Resolve an editor controller from the passed-in props. This method takes\n   * all of the props as individual arguments to be able to properly memoize\n   * against anything that could change and invalidate the old editor.\n   *\n   * @param {Array} plugins\n   * @param {Object} schema\n   * @param {Object} commands\n   * @param {Object} queries\n   * @param {String} placeholder\n   * @return {Editor}\n   */\n\n  resolveController = memoizeOne(\n    (plugins = [], schema, commands, queries, placeholder, TheReactPlugin) => {\n      // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n      warning(\n        this.tmp.resolves < 5 || this.tmp.resolves !== this.tmp.updates,\n        'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.'\n      )\n\n      this.tmp.resolves++\n      const react = TheReactPlugin({\n        ...this.props,\n        editor: this,\n        value: this.props.value || this.state.value,\n      })\n\n      const onChange = change => {\n        if (this.tmp.mounted) {\n          this.handleChange(change)\n        } else {\n          this.tmp.change = change\n        }\n      }\n\n      this.controller = new Controller(\n        { plugins: [react], onChange },\n        { controller: this, construct: false }\n      )\n\n      this.controller.run('onConstruct')\n    }\n  )\n\n  handleChange(change) {\n    const { onChange } = this.props\n    const { value } = this.state\n\n    if (value) {\n      // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n      this.setState({ value: change.value })\n    }\n\n    onChange(change)\n  }\n\n  /**\n   * Mimic the API of the `Editor` controller, so that this component instance\n   * can be passed in its place to plugins.\n   */\n\n  get operations() {\n    return this.controller.operations\n  }\n\n  get readOnly() {\n    return this.controller.readOnly\n  }\n\n  get value() {\n    return this.controller.value\n  }\n\n  applyOperation(...args) {\n    return this.controller.applyOperation(...args)\n  }\n\n  command(...args) {\n    return this.controller.command(...args)\n  }\n\n  hasCommand(...args) {\n    return this.controller.hasCommand(...args)\n  }\n\n  hasQuery(...args) {\n    return this.controller.hasQuery(...args)\n  }\n\n  normalize(...args) {\n    return this.controller.normalize(...args)\n  }\n\n  query(...args) {\n    return this.controller.query(...args)\n  }\n\n  registerCommand(...args) {\n    return this.controller.registerCommand(...args)\n  }\n\n  registerQuery(...args) {\n    return this.controller.registerQuery(...args)\n  }\n\n  run(...args) {\n    return this.controller.run(...args)\n  }\n\n  withoutNormalizing(...args) {\n    return this.controller.withoutNormalizing(...args)\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    return this.controller.editor\n  }\n\n  get schema() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  get stack() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  call(...args) {\n    return this.controller.call(...args)\n  }\n\n  change(...args) {\n    return this.controller.change(...args)\n  }\n\n  onChange(...args) {\n    return this.controller.onChange(...args)\n  }\n\n  applyOperations(...args) {\n    return this.controller.applyOperations(...args)\n  }\n\n  setOperationFlag(...args) {\n    return this.controller.setOperationFlag(...args)\n  }\n\n  getFlag(...args) {\n    return this.controller.getFlag(...args)\n  }\n\n  unsetOperationFlag(...args) {\n    return this.controller.unsetOperationFlag(...args)\n  }\n\n  withoutNormalization(...args) {\n    return this.controller.withoutNormalization(...args)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Editor\n","import findDOMNode from './find-dom-node'\nimport warning from 'tiny-warning'\n\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.'\n  )\n\n  const el = findDOMNode(point.key, win)\n  let start = 0\n\n  // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n  const texts = Array.from(\n    el.querySelectorAll(`${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`)\n  )\n\n  for (const text of texts) {\n    const node = text.childNodes[0]\n    const domLength = node.textContent.length\n    let slateLength = domLength\n\n    if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n      slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10)\n    }\n\n    const end = start + slateLength\n\n    if (point.offset <= end) {\n      const offset = Math.min(domLength, Math.max(0, point.offset - start))\n      return { node, offset }\n    }\n\n    start = end\n  }\n\n  return null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMPoint\n","import findDOMPoint from './find-dom-point'\nimport warning from 'tiny-warning'\n\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMRange(range, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.'\n  )\n\n  const { anchor, focus, isBackward, isCollapsed } = range\n  const domAnchor = findDOMPoint(anchor, win)\n  const domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win)\n\n  if (!domAnchor || !domFocus) return null\n\n  const r = win.document.createRange()\n  const start = isBackward ? domFocus : domAnchor\n  const end = isBackward ? domAnchor : domFocus\n  r.setStart(start.node, start.offset)\n  r.setEnd(end.node, end.offset)\n  return r\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMRange\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\nfunction findNode(element, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const closest = element.closest(SELECTORS.KEY)\n  if (!closest) return null\n\n  const key = closest.getAttribute(DATA_ATTRS.KEY)\n  if (!key) return null\n\n  const { value } = editor\n  const { document } = value\n  const node = document.getNode(key)\n  return node || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findNode\n","import findNode from './find-node'\nimport warning from 'tiny-warning'\n\n/**\n * Find a Slate path from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {List|Null}\n */\n\nfunction findPath(element, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.'\n  )\n\n  const node = findNode(element, editor)\n\n  if (!node) {\n    return null\n  }\n\n  const { value } = editor\n  const { document } = value\n  const path = document.getPath(node)\n  return path\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPath\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport OffsetKey from './offset-key'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.'\n  )\n\n  const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n    nativeNode,\n    nativeOffset\n  )\n\n  const window = getWindow(nativeNode)\n  const { parentNode } = nearestNode\n  let rangeNode = parentNode.closest(SELECTORS.LEAF)\n  let offset\n  let node\n\n  // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n  if (rangeNode) {\n    const range = window.document.createRange()\n    const textNode = rangeNode.closest(SELECTORS.TEXT)\n    range.setStart(textNode, 0)\n    range.setEnd(nearestNode, nearestOffset)\n    node = textNode\n\n    // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n    const fragment = range.cloneContents()\n    const zeroWidthNodes = fragment.querySelectorAll(\n      `[${DATA_ATTRS.ZERO_WIDTH}]`\n    )\n    offset = fragment.textContent.length - zeroWidthNodes.length\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    const voidNode = parentNode.closest(SELECTORS.VOID)\n    if (!voidNode) return null\n    rangeNode = voidNode.querySelector(SELECTORS.LEAF)\n    if (!rangeNode) return null\n    node = rangeNode\n    offset = node.textContent.length\n  }\n\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n  if (\n    offset === node.textContent.length &&\n    parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n  ) {\n    offset--\n  }\n\n  // Get the string value of the offset key attribute.\n  const offsetKey = rangeNode.getAttribute(DATA_ATTRS.OFFSET_KEY)\n  if (!offsetKey) return null\n\n  const { key } = OffsetKey.parse(offsetKey)\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  const { value } = editor\n  if (!value.document.hasDescendant(key)) return null\n\n  const point = value.document.createPoint({ key, offset })\n  return point\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType === 8 ||\n    (child.nodeType === 1 && child.childNodes.length === 0) ||\n    (child.nodeType === 1 && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction === 'forward') i++\n    if (direction === 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPoint\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport findPoint from './find-point'\n\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction findRange(native, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const el = native.anchorNode || native.startContainer\n  if (!el) return null\n\n  const window = getWindow(el)\n\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n  if (\n    native instanceof window.Range ||\n    (window.StaticRange && native instanceof window.StaticRange)\n  ) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset,\n    }\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n    isCollapsed,\n  } = native\n  const { value } = editor\n  const anchor = findPoint(anchorNode, anchorOffset, editor)\n  const focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor)\n  if (!anchor || !focus) return null\n\n  const { document } = value\n  const range = document.createRange({\n    anchor,\n    focus,\n  })\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findRange\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport findPath from './find-path'\nimport findRange from './find-range'\n\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction getEventRange(event, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const { clientX: x, clientY: y, target } = event\n  if (x == null || y == null) return null\n\n  const { value } = editor\n  const { document } = value\n  const path = findPath(event.target, editor)\n  if (!path) return null\n\n  const node = document.getNode(path)\n\n  // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n  if (editor.isVoid(node)) {\n    const rect = target.getBoundingClientRect()\n    const isPrevious =\n      node.object === 'inline'\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n    const range = document.createRange()\n    const move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode'\n    const entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path)\n\n    if (entry) {\n      return range[move](entry)\n    }\n\n    return null\n  }\n\n  // Else resolve a range from the caret position where the drop occured.\n  const window = getWindow(target)\n  let native\n\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y)\n  } else if (window.document.caretPositionFromPoint) {\n    const position = window.document.caretPositionFromPoint(x, y)\n    native = window.document.createRange()\n    native.setStart(position.offsetNode, position.offset)\n    native.setEnd(position.offsetNode, position.offset)\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange()\n\n    try {\n      native.moveToPoint(x, y)\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null\n    }\n  }\n\n  // Resolve a Slate range from the DOM range.\n  const range = findRange(native, editor)\n  if (!range) return null\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventRange\n","import Editor from './components/editor'\nimport cloneFragment from './utils/clone-fragment'\nimport findDOMNode from './utils/find-dom-node'\nimport findDOMPoint from './utils/find-dom-point'\nimport findDOMRange from './utils/find-dom-range'\nimport findNode from './utils/find-node'\nimport findPath from './utils/find-path'\nimport findPoint from './utils/find-point'\nimport findRange from './utils/find-range'\nimport getEventRange from './utils/get-event-range'\nimport getEventTransfer from './utils/get-event-transfer'\nimport setEventTransfer from './utils/set-event-transfer'\nimport ReactPlugin from './plugins/react'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMPoint,\n  findDOMRange,\n  findNode,\n  findPath,\n  findPoint,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n\nexport default {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMPoint,\n  findDOMRange,\n  findNode,\n  findPath,\n  findPoint,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n"],"names":["EVENT_HANDLERS","OTHER_HANDLERS","DATA_ATTRS","OBJECT","EDITOR","KEY","LEAF","STRING","VOID","ZERO_WIDTH","Inline","ref","React","createRef","nextProps","props","node","editor","parent","attributes","object","key","run","Component","PARSER","parse","string","matches","exec","Error","original","index","parseInt","stringify","Leaf","forceUpdateFlag","isZeroWidth","text","domNode","current","domTextContent","textContent","reactTextContent","oldDecorations","decorations","map","d","type","join","newDecorations","replace","isOnly","nodes","size","leaves","length","isLineBreak","shouldHaveLineBreak","IS_FIREFOX","hasAttribute","removeAttribute","LENGTH","setAttribute","childNodes","child","tagName","removeChild","hasLineBreak","appendChild","window","document","createElement","offset","offsetKey","OffsetKey","attrs","OFFSET_KEY","children","decoration","ret","Text","forwardRef","style","getLeaves","at","leaf","Block","tmp","nodeRefs","getDecorations","i","refFn","push","decs","getRelativeRange","filter","isLeafBlock","direction","getTextDirection","dir","range","isUnset","get","start","end","startPath","path","endPath","startIndex","first","endIndex","setPath","rest","moveTo","PathUtils","create","setKey","texts","firstNode","firstPath","last","lastNode","lastPath","setAnchor","setFocus","Document","OVERFLOWS","IS_IOS_11","IS_IOS","navigator","userAgent","match","findScrollContainer","el","parentNode","scroller","getComputedStyle","overflowY","includes","body","scrollToSelection","selection","anchorNode","getWindow","isWindow","documentElement","backward","isBackward","getRangeAt","cloneRange","collapse","cursorRect","getBoundingClientRect","IS_SAFARI","collapsed","top","height","startOffset","setEnd","endContainer","setStart","startContainer","getClientRects","width","yOffset","xOffset","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","innerWidth","innerHeight","pageYOffset","pageXOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","left","cursorTop","cursorLeft","x","y","scrollTo","removeAllRanges","domSelection","IS_IE","createTextRange","select","FIREFOX_NODE_TYPE_ACCESS_ERROR","debug","Debug","update","Content","setRef","domRef","handlers","reduce","obj","handler","onEvent","event","updateSelection","isComposing","HAS_INPUT_EVENTS_LEVEL_2","value","native","getSelection","activeElement","enabled","toJSON","rangeCount","updated","isBlurred","blur","propsToCompare","selectionsEqual","prop","nativeSelection","isInEditor","isFocused","focus","preventScroll","isSet","safelyFindDOMRange","endOffset","isUpdatingSelection","setBaseAndExtent","addRange","userActionPerformed","anchorOffset","focusOffset","target","nodeType","err","test","message","isContentEditable","closest","SELECTORS","onNativeSelectionChange","throttle","readOnly","focusNode","isCollapsed","error","info","setState","addEventListener","onBeforeInput","removeEventListener","clearUserActionPerformed","nativeEvent","isUndoRedo","Hotkeys","isUndo","isRedo","IS_ANDROID","findRange","equals","toRange","id","className","tabIndex","role","spellCheck","onContextMenu","Container","WebkitUserModify","contentKey","data","domProps","omit","Object","keys","__propTypes","autoCorrect","undefined","nodeRef","Types","bool","isRequired","number","func","defaultProps","findDOMRange","e","PROPS","EditorPropsPlugin","options","plugin","memo","Rendering","position","safelyGetParentKeyNode","parentElement","sanitizeDomOnError","fn","failed","warn","domElement","getAttribute","slateNode","getNode","blockNode","getClosestBlock","lineIndex","indexOf","log","replaceNodeByKey","newNode","textNode","point","Range","anchor","reconcileNode","getPath","findDOMNode","block","domText","isLastNode","lastChar","charAt","slice","entire","moveAnchorTo","moveFocusTo","resolveRange","insertTextAtRange","marks","reconcileDOMNode","findNode","CommandsPlugin","QueriesPlugin","content","contentRef","search","instance","p","findDOMPoint","Array","from","querySelectorAll","domLength","slateLength","Math","min","max","domAnchor","domFocus","r","createRange","element","findPath","findEventRange","clientX","clientY","isVoid","rect","isPrevious","move","entry","caretRangeFromPoint","caretPositionFromPoint","offsetNode","moveToPoint","nodeElement","docPath","n","findPoint","nativeNode","nativeOffset","normalizeNodeAndOffset","nearestNode","nearestOffset","leafNode","TEXT","contents","cloneContents","zeroWidths","forEach","voidNode","querySelector","createPoint","domRange","StaticRange","findSelection","anchorText","focusText","anchorInline","getClosestInline","focusInline","focusBlock","anchorBlock","setOffset","depth","getDepth","relativePath","drop","next","nextPath","absolutePath","concat","createSelection","setIsFocused","set","isLast","getEditableChild","triedForward","triedBackward","getDiffStart","prev","getDiffEnd","prevLength","nextLength","prevChar","nextChar","getDiffOffsets","maxEnd","total","sliceText","offsets","diff","insertText","removeText","ZERO_WIDTH_SPACE","String","fromCharCode","flushControlled","ReactDOM","unstable_flushControlled","renderSync","controller","flush","fixTextAndOffset","prevText","prevOffset","nextOffset","nextText","maxOffset","CompositionManager","observer","MutationObserver","win","connect","rootEl","observe","disconnect","clearDiff","clearAction","applyDiff","splitBlock","restoreDOM","mergeBlock","requestAnimationFrame","deleteBackward","onSelectTimeoutId","bufferedMutations","startActionFrameId","isFlushing","startAction","cancelAnimationFrame","mutations","flushAction","splitBlockMutation","find","m","addedNodes","addedNode","Node","TEXT_NODE","ELEMENT_NODE","dataset","firstMutation","removedNodes","resolveDOMNode","dataElement","getDescendant","fix","diffText","removeNode","nodeSelection","moveToRangeOfNode","delete","onCompositionStart","onCompositionEnd","setTimeout","onSelect","anchorFix","focusFix","normalizeDOMSelection","toJS","fixSelectionInZeroWidthBlock","slateZeroWidth","AndroidPlugin","onComponentDidMount","onComponentDidUpdate","onComponentWillUnmount","onRender","NoopPlugin","eventName","FRAGMENT","TRANSFER_TYPES","HTML","cloneFragment","callback","Value","isValue","fragment","startVoid","getClosestVoid","endVoid","encoded","Base64","serializeNode","attach","trim","setEndAfter","firstChild","call","isNewline","zw","span","whiteSpace","valFromSelection","plainText","Plain","serialize","div","clipboardData","setData","preventDefault","innerHTML","editorEl","selectAllChildren","NODE","RICH","FRAGMENT_MATCHER","getEventTransfer","transfer","dataTransfer","getType","html","rich","files","full","embeddedTypes","getEmbeddedTypes","deserializeNode","items","item","kind","getAsFile","exists","getTransferType","prefix","substring","JSON","types","getData","setEventTransfer","mime","toUpperCase","AfterPlugin","isDraggingInternally","isMouseDown","getTargetRanges","targetRange","inputType","deleteAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","deleteLineBackwardAtRange","deleteLineForwardAtRange","hasVoidParent","moveToStartOfNextText","splitBlockAtRange","onBlur","onClick","ancestors","getAncestors","some","a","moveToEndOfNode","onCopy","onCut","voidPath","removeNodeByKey","onDragEnd","onDragStart","selectionIncludesNode","blocks","onDrop","dispatchEvent","MouseEvent","draggedRange","nxt","moveToStartOfNode","split","line","insertFragment","onFocus","IS_EDGE","deselect","onInput","ENABLE_SLATE_LOGGING","console","onKeyDown","selectedBlock","isRtl","isDeleteBackward","deleteCharBackward","isDeleteForward","deleteCharForward","isDeleteLineBackward","deleteLineBackward","isDeleteLineForward","deleteLineForward","isDeleteWordBackward","deleteWordBackward","isDeleteWordForward","deleteWordForward","redo","undo","isMoveLineBackward","moveToEndOfBlock","moveToStartOfBlock","isMoveLineForward","isExtendLineBackward","moveFocusToEndOfBlock","moveFocusToStartOfBlock","isExtendLineForward","isMoveBackward","moveToEnd","moveToStart","moveForward","moveBackward","isMoveForward","isMoveWordBackward","moveWordForward","moveWordBackward","isMoveWordForward","isExtendBackward","isExtendForward","moveFocusBackward","moveFocusForward","onMouseDown","onMouseUp","onPaste","startBlock","defaultBlock","defaultMarks","getInsertMarksAtRange","frag","deserialize","isNode","BeforePlugin","isCopying","isDragging","isUserActionPerformed","nextNativeOperation","currentlySelectedCompositionNode","checkIsComposing","isSynthetic","inputText","hasNewLines","chunks","relatedTarget","SPACER","contains","onCompositionUpdate","onDragEnter","onDragExit","onDragLeave","onDragOver","dropEffect","syncDomToSlateAst","ctrlKey","altKey","shiftKey","metaKey","which","isCompose","toLowerCase","isBold","isItalic","isTransposeCharacter","nodesToIncorporate","currentOffset","syncNodeToSlateAst","syncSelection","slateDomSpan","findDomNode","slateAstNode","newTextContent","newSelectionPosition","syncTextToAst","newText","oldText","numStartingCharsSame","commonCharactersAtStart","numEndingCharsSame","commonCharactersAtEnd","insertions","fastInsertText","right","leftLength","rightLength","setSlateSelection","setDomSelection","sanitizeZeroWidthSpaces","allChildTextNodes","stringNode","isStringNode","hasZeroWidthChars","removeZeroWidths","pos","deleteData","eachTextNode","cb","saveCurrentNativeNode","saveCurrentlySelectedCompositionNode","addCurrentlySelectedKeyNode","keyNodes","currentSpan","DOMPlugin","plugins","beforePlugin","afterPlugin","androidPlugins","RestoreDOMPlugin","stringifyEvent","DebugEventsPlugin","s","INTERVAL","DebugBatchEventsPlugin","startDate","timeoutId","events","dumpEvents","pushEvent","Date","now","MUTATION_PROPERTIES","normalizeNode","outerHTML","DebugMutationsPlugin","array","mutationRecord","NodeList","prevRootEl","stop","ReactPlugin","placeholder","debugEventsPlugin","debugBatchEventsPlugin","debugMutationsPlugin","renderingPlugin","RenderingPlugin","commandsPlugin","queriesPlugin","editorPropsPlugin","domPlugin","restoreDomPlugin","placeholderPlugin","PlaceholderPlugin","Editor","state","defaultValue","resolveController","memoizeOne","TheReactPlugin","resolves","updates","react","onChange","mounted","handleChange","change","Controller","construct","autoFocus","commands","queries","schema","valueFromProps","valueFromState","setReadOnly","setValue","applyOperation","command","hasCommand","hasQuery","normalize","query","registerCommand","registerQuery","withoutNormalizing","applyOperations","setOperationFlag","getFlag","unsetOperationFlag","withoutNormalization","operations","SlateTypes","any","rangeNode","zeroWidthNodes","hasDescendant","getEventRange"],"mappings":"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"}